
/home/pi/pinetime-rust-mynewt/bin/targets/nrf52_boot/app/apps/boot_stub/boot_stub.elf:     file format elf32-littlearm
/home/pi/pinetime-rust-mynewt/bin/targets/nrf52_boot/app/apps/boot_stub/boot_stub.elf
architecture: arm, flags 0x00000112:
EXEC_P, HAS_SYMS, D_PAGED
start address 0x000000d9

Program Header:
0x70000001 off    0x00010b48 vaddr 0x00000b48 paddr 0x00000b48 align 2**2
         filesz 0x00000018 memsz 0x00000018 flags r--
    LOAD off    0x00010000 vaddr 0x00000000 paddr 0x00000000 align 2**16
         filesz 0x00000b60 memsz 0x00000b60 flags r-x
    LOAD off    0x000200d8 vaddr 0x200000d8 paddr 0x00000b60 align 2**16
         filesz 0x00000018 memsz 0x00000044 flags rw-
    LOAD off    0x00030000 vaddr 0x20000000 paddr 0x20000000 align 2**16
         filesz 0x00000000 memsz 0x000000d8 flags rw-
private flags = 5000200: [Version5 EABI] [soft-float ABI]

Sections:
Idx Name               Size      VMA       LMA       File off  Algn  Flags
  0 .text              00000b48  00000000  00000000  00010000  2**2  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .ARM.extab         00000000  00000b48  00000b48  000200f0  2**0  CONTENTS
  2 .ARM.exidx         00000018  00000b48  00000b48  00010b48  2**2  CONTENTS, ALLOC, LOAD, READONLY, DATA
  3 .vector_relocation 000000d8  20000000  20000000  00030000  2**0  ALLOC
  4 .rtt               00000000  200000d8  200000d8  000200f0  2**0  CONTENTS
  5 .data              00000018  200000d8  00000b60  000200d8  2**2  CONTENTS, ALLOC, LOAD, DATA
  6 .bssnz             00000000  200000f0  200000f0  000200f0  2**0  CONTENTS
  7 .bss               0000002c  200000f0  00000b78  000200f0  2**2  ALLOC
  8 .stack_dummy       000001b0  20000120  20000120  000200f0  2**3  CONTENTS, READONLY
  9 .ARM.attributes    0000002f  00000000  00000000  000202a0  2**0  CONTENTS, READONLY
 10 .comment           00000057  00000000  00000000  000202cf  2**0  CONTENTS, READONLY
 11 .svc_table         00000004  00000000  00000000  00020326  2**0  CONTENTS, READONLY
 12 .debug_line        00003fa1  00000000  00000000  0002032a  2**0  CONTENTS, READONLY, DEBUGGING
 13 .debug_info        0000a2a2  00000000  00000000  000242cb  2**0  CONTENTS, READONLY, DEBUGGING
 14 .debug_abbrev      00001ffa  00000000  00000000  0002e56d  2**0  CONTENTS, READONLY, DEBUGGING
 15 .debug_aranges     000004f0  00000000  00000000  00030568  2**3  CONTENTS, READONLY, DEBUGGING
 16 .debug_str         00002488  00000000  00000000  00030a58  2**0  CONTENTS, READONLY, DEBUGGING
 17 .debug_loc         00001e98  00000000  00000000  00032ee0  2**0  CONTENTS, READONLY, DEBUGGING
 18 .debug_ranges      000003b0  00000000  00000000  00034d78  2**0  CONTENTS, READONLY, DEBUGGING
 19 .debug_frame       000009d4  00000000  00000000  00035128  2**2  CONTENTS, READONLY, DEBUGGING
SYMBOL TABLE:
00000000 l    d  .text	00000000 .text
00000b48 l    d  .ARM.extab	00000000 .ARM.extab
00000b48 l    d  .ARM.exidx	00000000 .ARM.exidx
20000000 l    d  .vector_relocation	00000000 .vector_relocation
200000d8 l    d  .rtt	00000000 .rtt
200000d8 l    d  .data	00000000 .data
200000f0 l    d  .bssnz	00000000 .bssnz
200000f0 l    d  .bss	00000000 .bss
20000120 l    d  .stack_dummy	00000000 .stack_dummy
00000000 l    d  .ARM.attributes	00000000 .ARM.attributes
00000000 l    d  .comment	00000000 .comment
00000000 l    d  .svc_table	00000000 .svc_table
00000000 l    d  .debug_line	00000000 .debug_line
00000000 l    d  .debug_info	00000000 .debug_info
00000000 l    d  .debug_abbrev	00000000 .debug_abbrev
00000000 l    d  .debug_aranges	00000000 .debug_aranges
00000000 l    d  .debug_str	00000000 .debug_str
00000000 l    d  .debug_loc	00000000 .debug_loc
00000000 l    d  .debug_ranges	00000000 .debug_ranges
00000000 l    d  .debug_frame	00000000 .debug_frame
00000000 l    df *ABS*	00000000 gcc_startup_nrf52.o
000001b0 l       *ABS*	00000000 Stack_Size
00000000 l       *ABS*	00000000 Heap_Size
000000e0 l       .text	00000000 .bss_zero_loop
00000000 l    df *ABS*	00000000 sbrk.c
200000d8 l     O .data	00000004 sbrkBase
200000dc l     O .data	00000004 sbrkLimit
200000e0 l     O .data	00000004 brk
00000000 l    df *ABS*	00000000 hal_system.c
00000000 l    df *ABS*	00000000 system_nrf52.c
000001ec l     F .text	0000003c errata_16
00000228 l     F .text	0000004c errata_31
00000274 l     F .text	0000003c errata_32
000002b0 l     F .text	0000004c errata_36
000002fc l     F .text	0000003c errata_37
00000338 l     F .text	0000003c errata_57
00000374 l     F .text	0000003c errata_66
000003b0 l     F .text	0000004c errata_108
00000000 l    df *ABS*	00000000 start.c
00000000 l    df *ABS*	00000000 boot.c
00000000 l    df *ABS*	00000000 hal_bsp.c
00000000 l    df *ABS*	00000000 cmsis_nvic.c
00000000 l    df *ABS*	00000000 hal_common.c
00000000 l    df *ABS*	00000000 hal_system_start.c
00000000 l    df *ABS*	00000000 nrf52_periph.c
00000640 l     F .text	00000034 nrf52_periph_create_timers
00000000 l    df *ABS*	00000000 hal_timer.c
0000067c l     F .text	0000000a nrf_read_timer_cntr
00000688 l     F .text	000000b4 nrf_timer_set_ocmp
0000073c l     F .text	0000000a nrf_timer_disable_ocmp
00000746 l     F .text	0000000a nrf_rtc_disable_ocmp
00000750 l     F .text	00000054 hal_timer_read_bsptimer
000007a4 l     F .text	00000076 hal_timer_chk_queue
0000081a l     F .text	0000002c hal_timer_irq_handler
00000ae8 l     O .text	00000018 nrf52_hal_timers
00000000 l    df *ABS*	00000000 os_fault.c
00000000 l    df *ABS*	00000000 os_cputime.c
00000000 l    df *ABS*	00000000 os_arch_arm.c
00000000 l    df *ABS*	00000000 os_time.c
00000000 l    df *ABS*	00000000 HAL_CM4.o
00000a5c l       .text	00000000 SVC_User
00000a7a l       .text	00000000 SVC_Done
00000000 l    df *ABS*	00000000 nrf52_boot-sysflash.c
00000000 l    df *ABS*	00000000 os_sched.c
00000000 l    df *ABS*	00000000 SVC_Table.S
00000000 l       .svc_table	00000000 SVC_End
20000120 g       .bss	00000000 __HeapBase
00000000 g       .svc_table	00000000 SVC_Count
00000144  w    F .text	00000002 TIMER2_IRQHandler
00000144  w    F .text	00000002 RTC0_IRQHandler
200000d8 g       .data	00000000 __data_start__
00000144  w    F .text	00000002 SWI0_EGU0_IRQHandler
00000136  w    F .text	00000002 HardFault_Handler
00000858 g     F .text	00000060 hal_timer_init
00000636 g     F .text	0000000a hal_system_start
00000144  w    F .text	00000002 SWI2_EGU2_IRQHandler
00000aaa g     F .text	0000000c SysTick_Handler
00000144  w    F .text	00000002 GPIOTE_IRQHandler
00000848 g     F .text	00000010 nrf52_timer0_irq_handler
00000144  w    F .text	00000002 PWM1_IRQHandler
00000a80 g     F .text	0000002a PendSV_Handler
00000134  w    F .text	00000002 NMI_Handler
00000b60 g       .ARM.exidx	00000000 __exidx_end
00000000 g       .text	00000000 __isr_vector_start
00000174 g     F .text	0000002c hal_system_reset
200000f0 g       .data	00000000 __aeabi_unwind_cpp_pr0
00000144  w    F .text	00000002 POWER_CLOCK_IRQHandler
00000b60 g       .ARM.exidx	00000000 __etext
00000144  w    F .text	00000002 RADIO_IRQHandler
200000f0 g       .bssnz	00000000 __bssnz_start__
00000144  w    F .text	00000002 PDM_IRQHandler
00000144  w    F .text	00000002 TEMP_IRQHandler
00000144  w    F .text	00000002 QDEC_IRQHandler
00000144  w    F .text	00000002 TIMER3_IRQHandler
000009f8 g     F .text	0000000a timer_handler
000009ec g     F .text	0000000c os_cputime_init
00000000 g       *ABS*	00000000 _imghdr_size
200000e4 g     O .data	00000004 SystemCoreClock
00000158 g     F .text	0000000c hal_system_init
00000144  w    F .text	00000002 SPIM0_SPIS0_TWIM0_TWIS0_SPI0_TWI0_IRQHandler
000009b0 g     F .text	00000024 __assert_func
0000013c  w    F .text	00000002 UsageFault_Handler
00000144  w    F .text	00000002 UARTE0_UART0_IRQHandler
2000fe50 g       *ABS*	00000000 __HeapLimit
200000f0 g       .bss	00000000 __bss_start__
00000164 g     F .text	00000010 hal_debugger_connected
00000144  w    F .text	00000002 TIMER4_IRQHandler
20000110 g     O .bss	00000004 g_current_task
00000a02 g     F .text	0000000c os_arch_save_sr
00000b48 g       .text	00000000 __exidx_start
00000a20 g     F .text	00000014 os_set_env
00000674 g     F .text	00000008 nrf52_periph_create
00000144  w    F .text	00000002 I2S_IRQHandler
000005da g     F .text	00000002 _init
00000144  w    F .text	00000002 SWI4_EGU4_IRQHandler
00000144  w    F .text	00000002 TIMER0_IRQHandler
000000d8 g     F .text	0000005c Reset_Handler
00000ab6 g     F .text	0000001e os_default_irq_asm
00000148 g     F .text	00000010 _sbrkInit
200000f0 g       .bssnz	00000000 __bssnz_end__
00000144  w    F .text	00000002 TIMER1_IRQHandler
20000000 g       .bss	00000000 _ram_start
20000000 g       .vector_relocation	00000000 __vector_tbl_reloc__
00000144  w    F .text	00000002 PWM2_IRQHandler
200000f0 g       .data	00000000 __data_end__
00000144  w    F .text	00000002 ECB_IRQHandler
20000118 g     O .bss	00000004 g_os_time
2000011c g       .bss	00000000 __bss_end__
00000144  w    F .text	00000002 SPIM1_SPIS1_TWIM1_TWIS1_SPI1_TWI1_IRQHandler
00000144 g     F .text	00000002 Default_Handler
000005cc g     F .text	0000000e _start
00000a34 g     F .text	00000006 os_arch_init_task_stack
000009d4 g     F .text	00000018 os_default_irq
20000114 g     O .bss	00000004 g_os_last_ctx_sw_time
000008b8 g     F .text	000000f8 hal_timer_config
00000144  w    F .text	00000002 SAADC_IRQHandler
00000000 g       .text	000000d8 __isr_vector
000005dc g     F .text	00000014 main
00000144  w    F .text	00000002 CCM_AAR_IRQHandler
00000144  w    F .text	00000002 WDT_IRQHandler
00000a3a g     F .text	00000046 SVC_Handler
00000144  w    F .text	00000002 SWI5_EGU5_IRQHandler
00000000 g       .text	00000000 __text
0000040c g     F .text	000001c0 SystemInit
00000144  w    F .text	00000002 RNG_IRQHandler
00000000 g       .svc_table	00000000 SVC_Table
00000144  w    F .text	00000002 RTC2_IRQHandler
20010000 g       .bss	00000000 __StackTop
00000144  w    F .text	00000002 PWM0_IRQHandler
00000144  w    F .text	00000002 SWI3_EGU3_IRQHandler
00000b00 g     O .text	00000048 sysflash_map_dflt
200000f4 g     O .bss	0000001c nrf52_hal_timer0
000000d8 g       .text	00000000 __isr_vector_end
00000144  w    F .text	00000002 RTC1_IRQHandler
00000144  w    F .text	00000002 SWI1_EGU1_IRQHandler
200000e8 g     O .data	00000008 g_os_run_list
000005fc g     F .text	00000034 NVIC_Relocate
200000f0 g     O .bss	00000004 os_flags
2000fe50 g       *ABS*	000001b0 __StackLimit
00000144  w    F .text	00000002 SPIM2_SPIS2_SPI2_IRQHandler
00000144  w    F .text	00000002 NFCT_IRQHandler
000003fc g     F .text	00000010 SystemCoreClockUpdate
00000630 g     F .text	00000006 _exit
000001a0 g     F .text	0000004c hal_system_clock_start
0000013a  w    F .text	00000002 BusFault_Handler
00000a10 g     F .text	00000010 os_time_advance
00000144  w    F .text	00000002 MWU_IRQHandler
00000138  w    F .text	00000002 MemoryManagement_Handler
00000144  w    F .text	00000002 COMP_LPCOMP_IRQHandler
000005f0 g     F .text	0000000c hal_bsp_init



Disassembly of section .text:

00000000 <__isr_vector>:
 * NOTE: must be called with interrupts disabled! This function does not call
 * the scheduler
 */
int
os_sched_sleep(struct os_task *t, os_time_t nticks)
{
   0:	20010000 	.word	0x20010000
   4:	000000d9 	.word	0x000000d9
    struct os_task *entry;

    entry = NULL;

    TAILQ_REMOVE(&g_os_run_list, t, t_os_list);
   8:	00000135 	.word	0x00000135
   c:	00000137 	.word	0x00000137
	...
    if (nticks == OS_TIMEOUT_NEVER) {
        t->t_flags |= OS_TASK_FLAG_NO_TIMEOUT;
        TAILQ_INSERT_TAIL(&g_os_sleep_list, t, t_os_list);
    } else {
        TAILQ_FOREACH(entry, &g_os_sleep_list, t_os_list) {
            if ((entry->t_flags & OS_TASK_FLAG_NO_TIMEOUT) ||
  2c:	00000a3b 	.word	0x00000a3b
	...
  38:	00000a81 	.word	0x00000a81
        TAILQ_FOREACH(entry, &g_os_sleep_list, t_os_list) {
  3c:	00000aab 	.word	0x00000aab
    TAILQ_REMOVE(&g_os_run_list, t, t_os_list);
  40:	00000145 	.word	0x00000145
  44:	00000145 	.word	0x00000145
        t->t_flags |= OS_TASK_FLAG_NO_TIMEOUT;
  48:	00000145 	.word	0x00000145
  4c:	00000145 	.word	0x00000145
        TAILQ_INSERT_TAIL(&g_os_sleep_list, t, t_os_list);
  50:	00000145 	.word	0x00000145
  54:	00000145 	.word	0x00000145
  58:	00000145 	.word	0x00000145
  5c:	00000145 	.word	0x00000145
  60:	00000145 	.word	0x00000145
                    OS_TIME_TICK_GT(entry->t_next_wakeup, t->t_next_wakeup)) {
                break;
            }
        }
        if (entry) {
            TAILQ_INSERT_BEFORE(entry, t, t_os_list);
  64:	00000145 	.word	0x00000145
  68:	00000145 	.word	0x00000145
  6c:	00000145 	.word	0x00000145
  70:	00000145 	.word	0x00000145
        }
    }

    os_trace_task_stop_ready(t, OS_TASK_SLEEP);
    return (0);
}
  74:	00000145 	.word	0x00000145
            TAILQ_INSERT_TAIL(&g_os_sleep_list, t, t_os_list);
  78:	00000145 	.word	0x00000145
  7c:	00000145 	.word	0x00000145
  80:	00000145 	.word	0x00000145
  84:	00000145 	.word	0x00000145
  88:	00000145 	.word	0x00000145
  8c:	00000145 	.word	0x00000145
  90:	00000145 	.word	0x00000145
  94:	00000145 	.word	0x00000145
  98:	00000145 	.word	0x00000145
  9c:	00000145 	.word	0x00000145
  a0:	00000145 	.word	0x00000145
  a4:	00000145 	.word	0x00000145
  a8:	00000145 	.word	0x00000145
  ac:	00000145 	.word	0x00000145
  b0:	00000145 	.word	0x00000145
  b4:	00000145 	.word	0x00000145
	...
  c0:	00000145 	.word	0x00000145
  c4:	00000145 	.word	0x00000145
  c8:	00000145 	.word	0x00000145
  cc:	00000145 	.word	0x00000145
  d0:	00000145 	.word	0x00000145
  d4:	00000145 	.word	0x00000145

000000d8 <Reset_Handler>:
    .type    Reset_Handler, %function
Reset_Handler:
    .fnstart

    /* Clear BSS */
    mov     r0, #0
  d8:	f04f 0000 	mov.w	r0, #0
    ldr     r2, =__bss_start__
  dc:	4a0c      	ldr	r2, [pc, #48]	; (110 <.bss_zero_loop+0x30>)
    ldr     r3, =__bss_end__
  de:	4b0d      	ldr	r3, [pc, #52]	; (114 <.bss_zero_loop+0x34>)

000000e0 <.bss_zero_loop>:
.bss_zero_loop:
    cmp     r2, r3
  e0:	429a      	cmp	r2, r3
    itt     lt
  e2:	bfbc      	itt	lt
    strlt   r0, [r2], #4
  e4:	f842 0b04 	strlt.w	r0, [r2], #4
    blt    .bss_zero_loop
  e8:	e7fa      	blt.n	e0 <.bss_zero_loop>
 *      of copy from/to are specified by following symbols evaluated in
 *      linker script.
 *      __etext: End of code section, i.e., begin of data sections to copy from.
 *      __data_start__/__data_end__: RAM address range that data should be
 *      copied to. Both must be aligned to 4 bytes boundary.  */
    ldr    r1, =__etext
  ea:	490b      	ldr	r1, [pc, #44]	; (118 <.bss_zero_loop+0x38>)
    ldr    r2, =__data_start__
  ec:	4a0b      	ldr	r2, [pc, #44]	; (11c <.bss_zero_loop+0x3c>)
    ldr    r3, =__data_end__
  ee:	4b0c      	ldr	r3, [pc, #48]	; (120 <.bss_zero_loop+0x40>)

    subs    r3, r2
  f0:	1a9b      	subs	r3, r3, r2
    ble     .LC0
  f2:	dd03      	ble.n	fc <.bss_zero_loop+0x1c>

.LC1:
    subs    r3, 4
  f4:	3b04      	subs	r3, #4
    ldr    r0, [r1,r3]
  f6:	58c8      	ldr	r0, [r1, r3]
    str    r0, [r2,r3]
  f8:	50d0      	str	r0, [r2, r3]
    bgt    .LC1
  fa:	dcfb      	bgt.n	f4 <.bss_zero_loop+0x14>

.LC0:

    LDR     R0, =__HeapBase
  fc:	4809      	ldr	r0, [pc, #36]	; (124 <.bss_zero_loop+0x44>)
    LDR     R1, =__HeapLimit
  fe:	490a      	ldr	r1, [pc, #40]	; (128 <.bss_zero_loop+0x48>)
    BL      _sbrkInit
 100:	f000 f822 	bl	148 <_sbrkInit>

    LDR     R0, =SystemInit
 104:	4809      	ldr	r0, [pc, #36]	; (12c <.bss_zero_loop+0x4c>)
    BLX     R0
 106:	4780      	blx	r0

    BL      hal_system_init
 108:	f000 f826 	bl	158 <hal_system_init>

    LDR     R0, =_start
 10c:	4808      	ldr	r0, [pc, #32]	; (130 <.bss_zero_loop+0x50>)
    BX      R0
 10e:	4700      	bx	r0
    ldr     r2, =__bss_start__
 110:	200000f0 	.word	0x200000f0
    ldr     r3, =__bss_end__
 114:	2000011c 	.word	0x2000011c
    ldr    r1, =__etext
 118:	00000b60 	.word	0x00000b60
    ldr    r2, =__data_start__
 11c:	200000d8 	.word	0x200000d8
    ldr    r3, =__data_end__
 120:	200000f0 	.word	0x200000f0
    LDR     R0, =__HeapBase
 124:	20000120 	.word	0x20000120
    LDR     R1, =__HeapLimit
 128:	2000fe50 	.word	0x2000fe50
    LDR     R0, =SystemInit
 12c:	0000040d 	.word	0x0000040d
    LDR     R0, =_start
 130:	000005cd 	.word	0x000005cd

00000134 <NMI_Handler>:
/* Dummy Exception Handlers (infinite loops which can be modified) */

    .weak   NMI_Handler
    .type   NMI_Handler, %function
NMI_Handler:
    B       .
 134:	e7fe      	b.n	134 <NMI_Handler>

00000136 <HardFault_Handler>:


    .weak   HardFault_Handler
    .type   HardFault_Handler, %function
HardFault_Handler:
    B       .
 136:	e7fe      	b.n	136 <HardFault_Handler>

00000138 <MemoryManagement_Handler>:


    .weak   MemoryManagement_Handler
    .type   MemoryManagement_Handler, %function
MemoryManagement_Handler:
    B       .
 138:	e7fe      	b.n	138 <MemoryManagement_Handler>

0000013a <BusFault_Handler>:


    .weak   BusFault_Handler
    .type   BusFault_Handler, %function
BusFault_Handler:
    B       .
 13a:	e7fe      	b.n	13a <BusFault_Handler>

0000013c <UsageFault_Handler>:


    .weak   UsageFault_Handler
    .type   UsageFault_Handler, %function
UsageFault_Handler:
    B       .
 13c:	e7fe      	b.n	13c <UsageFault_Handler>


    .weak   SVC_Handler
    .type   SVC_Handler, %function
SVC_Handler:
    B       .
 13e:	e7fe      	b.n	13e <UsageFault_Handler+0x2>


    .weak   PendSV_Handler
    .type   PendSV_Handler, %function
PendSV_Handler:
    B       .
 140:	e7fe      	b.n	140 <UsageFault_Handler+0x4>


    .weak   SysTick_Handler
    .type   SysTick_Handler, %function
SysTick_Handler:
    B       .
 142:	e7fe      	b.n	142 <UsageFault_Handler+0x6>

00000144 <Default_Handler>:
/* IRQ Handlers */

    .globl  Default_Handler
    .type   Default_Handler, %function
Default_Handler:
    B       .
 144:	e7fe      	b.n	144 <Default_Handler>
 146:	bf00      	nop

00000148 <_sbrkInit>:
static char *sbrkLimit __attribute__ ((section (".data")));
static char *brk __attribute__ ((section (".data")));

void
_sbrkInit(char *base, char *limit) {
    sbrkBase = base;
 148:	4b02      	ldr	r3, [pc, #8]	; (154 <_sbrkInit+0xc>)
 14a:	6018      	str	r0, [r3, #0]
    sbrkLimit = limit;
 14c:	6059      	str	r1, [r3, #4]
    brk = base;
 14e:	6098      	str	r0, [r3, #8]
}
 150:	4770      	bx	lr
 152:	bf00      	nop
 154:	200000d8 	.word	0x200000d8

00000158 <hal_system_init>:
 */
void
hal_system_init(void)
{
#if MYNEWT_VAL(MCU_DCDC_ENABLED)
    NRF_POWER->DCDCEN = 1;
 158:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 15c:	2201      	movs	r2, #1
 15e:	f8c3 2578 	str.w	r2, [r3, #1400]	; 0x578
#endif
}
 162:	4770      	bx	lr

00000164 <hal_debugger_connected>:
}

int
hal_debugger_connected(void)
{
    return CoreDebug->DHCSR & CoreDebug_DHCSR_C_DEBUGEN_Msk;
 164:	4b02      	ldr	r3, [pc, #8]	; (170 <hal_debugger_connected+0xc>)
 166:	6818      	ldr	r0, [r3, #0]
}
 168:	f000 0001 	and.w	r0, r0, #1
 16c:	4770      	bx	lr
 16e:	bf00      	nop
 170:	e000edf0 	.word	0xe000edf0

00000174 <hal_system_reset>:
{
 174:	b508      	push	{r3, lr}
        if (hal_debugger_connected()) {
 176:	f7ff fff5 	bl	164 <hal_debugger_connected>
 17a:	b100      	cbz	r0, 17e <hal_system_reset+0xa>
            asm("bkpt");
 17c:	be00      	bkpt	0x0000
  \details Acts as a special kind of Data Memory Barrier.
           It completes when all explicit memory accesses before this instruction complete.
 */
__STATIC_FORCEINLINE void __DSB(void)
{
  __ASM volatile ("dsb 0xF":::"memory");
 17e:	f3bf 8f4f 	dsb	sy
__NO_RETURN __STATIC_INLINE void __NVIC_SystemReset(void)
{
  __DSB();                                                          /* Ensure all outstanding memory accesses included
                                                                       buffered write are completed before reset */
  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
                           (SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) |
 182:	4905      	ldr	r1, [pc, #20]	; (198 <hal_system_reset+0x24>)
 184:	68ca      	ldr	r2, [r1, #12]
 186:	f402 62e0 	and.w	r2, r2, #1792	; 0x700
  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
 18a:	4b04      	ldr	r3, [pc, #16]	; (19c <hal_system_reset+0x28>)
 18c:	4313      	orrs	r3, r2
 18e:	60cb      	str	r3, [r1, #12]
 190:	f3bf 8f4f 	dsb	sy
                            SCB_AIRCR_SYSRESETREQ_Msk    );         /* Keep priority group unchanged */
  __DSB();                                                          /* Ensure completion of memory access */

  for(;;)                                                           /* wait until reset */
  {
    __NOP();
 194:	bf00      	nop
 196:	e7fd      	b.n	194 <hal_system_reset+0x20>
 198:	e000ed00 	.word	0xe000ed00
 19c:	05fa0004 	.word	0x05fa0004

000001a0 <hal_system_clock_start>:
        }
    }
#endif

    /* Check if this clock source is already running */
    if ((NRF_CLOCK->LFCLKSTAT & regmsk) != regval) {
 1a0:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 1a4:	f8d3 2418 	ldr.w	r2, [r3, #1048]	; 0x418
 1a8:	4b0f      	ldr	r3, [pc, #60]	; (1e8 <Stack_Size+0x38>)
 1aa:	4013      	ands	r3, r2
 1ac:	f1b3 1f01 	cmp.w	r3, #65537	; 0x10001
 1b0:	d018      	beq.n	1e4 <Stack_Size+0x34>
        NRF_CLOCK->TASKS_LFCLKSTOP = 1;
 1b2:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 1b6:	2201      	movs	r2, #1
 1b8:	60da      	str	r2, [r3, #12]
        NRF_CLOCK->EVENTS_LFCLKSTARTED = 0;
 1ba:	2100      	movs	r1, #0
 1bc:	f8c3 1104 	str.w	r1, [r3, #260]	; 0x104
        NRF_CLOCK->LFCLKSRC = clksrc;
 1c0:	f8c3 2518 	str.w	r2, [r3, #1304]	; 0x518
        NRF_CLOCK->TASKS_LFCLKSTART = 1;
 1c4:	609a      	str	r2, [r3, #8]

        /* Wait here till started! */
        while (1) {
            if (NRF_CLOCK->EVENTS_LFCLKSTARTED) {
 1c6:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 1ca:	f8d3 3104 	ldr.w	r3, [r3, #260]	; 0x104
 1ce:	2b00      	cmp	r3, #0
 1d0:	d0f9      	beq.n	1c6 <Stack_Size+0x16>
                if ((NRF_CLOCK->LFCLKSTAT & regmsk) == regval) {
 1d2:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 1d6:	f8d3 2418 	ldr.w	r2, [r3, #1048]	; 0x418
 1da:	4b03      	ldr	r3, [pc, #12]	; (1e8 <Stack_Size+0x38>)
 1dc:	4013      	ands	r3, r2
 1de:	f1b3 1f01 	cmp.w	r3, #65537	; 0x10001
 1e2:	d1f0      	bne.n	1c6 <Stack_Size+0x16>
                }
            }
        }
    }
#endif
}
 1e4:	4770      	bx	lr
 1e6:	bf00      	nop
 1e8:	00010003 	.word	0x00010003

000001ec <errata_16>:
}

#ifdef NRF52
static bool errata_16(void)
{
    if ((((*(uint32_t *)0xF0000FE0) & 0x000000FF) == 0x6) && (((*(uint32_t *)0xF0000FE4) & 0x0000000F) == 0x0)){
 1ec:	4b0b      	ldr	r3, [pc, #44]	; (21c <errata_16+0x30>)
 1ee:	781b      	ldrb	r3, [r3, #0]
 1f0:	2b06      	cmp	r3, #6
 1f2:	d001      	beq.n	1f8 <errata_16+0xc>
        if (((*(uint32_t *)0xF0000FE8) & 0x000000F0) == 0x30){
            return true;
        }
    }

    return false;
 1f4:	2000      	movs	r0, #0
 1f6:	4770      	bx	lr
    if ((((*(uint32_t *)0xF0000FE0) & 0x000000FF) == 0x6) && (((*(uint32_t *)0xF0000FE4) & 0x0000000F) == 0x0)){
 1f8:	4b09      	ldr	r3, [pc, #36]	; (220 <errata_16+0x34>)
 1fa:	681b      	ldr	r3, [r3, #0]
 1fc:	f013 0f0f 	tst.w	r3, #15
 200:	d107      	bne.n	212 <errata_16+0x26>
        if (((*(uint32_t *)0xF0000FE8) & 0x000000F0) == 0x30){
 202:	4b08      	ldr	r3, [pc, #32]	; (224 <errata_16+0x38>)
 204:	681b      	ldr	r3, [r3, #0]
 206:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
 20a:	2b30      	cmp	r3, #48	; 0x30
 20c:	d003      	beq.n	216 <errata_16+0x2a>
    return false;
 20e:	2000      	movs	r0, #0
 210:	4770      	bx	lr
 212:	2000      	movs	r0, #0
 214:	4770      	bx	lr
            return true;
 216:	2001      	movs	r0, #1
}
 218:	4770      	bx	lr
 21a:	bf00      	nop
 21c:	f0000fe0 	.word	0xf0000fe0
 220:	f0000fe4 	.word	0xf0000fe4
 224:	f0000fe8 	.word	0xf0000fe8

00000228 <errata_31>:

static bool errata_31(void)
{
    if ((((*(uint32_t *)0xF0000FE0) & 0x000000FF) == 0x6) && (((*(uint32_t *)0xF0000FE4) & 0x0000000F) == 0x0)){
 228:	4b0f      	ldr	r3, [pc, #60]	; (268 <errata_31+0x40>)
 22a:	781b      	ldrb	r3, [r3, #0]
 22c:	2b06      	cmp	r3, #6
 22e:	d001      	beq.n	234 <errata_31+0xc>
        if (((*(uint32_t *)0xF0000FE8) & 0x000000F0) == 0x50){
            return true;
        }
    }

    return false;
 230:	2000      	movs	r0, #0
 232:	4770      	bx	lr
    if ((((*(uint32_t *)0xF0000FE0) & 0x000000FF) == 0x6) && (((*(uint32_t *)0xF0000FE4) & 0x0000000F) == 0x0)){
 234:	4b0d      	ldr	r3, [pc, #52]	; (26c <errata_31+0x44>)
 236:	681b      	ldr	r3, [r3, #0]
 238:	f013 0f0f 	tst.w	r3, #15
 23c:	d10b      	bne.n	256 <errata_31+0x2e>
        if (((*(uint32_t *)0xF0000FE8) & 0x000000F0) == 0x30){
 23e:	4b0c      	ldr	r3, [pc, #48]	; (270 <errata_31+0x48>)
 240:	681b      	ldr	r3, [r3, #0]
 242:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
 246:	2b30      	cmp	r3, #48	; 0x30
 248:	d007      	beq.n	25a <errata_31+0x32>
        if (((*(uint32_t *)0xF0000FE8) & 0x000000F0) == 0x40){
 24a:	2b40      	cmp	r3, #64	; 0x40
 24c:	d007      	beq.n	25e <errata_31+0x36>
        if (((*(uint32_t *)0xF0000FE8) & 0x000000F0) == 0x50){
 24e:	2b50      	cmp	r3, #80	; 0x50
 250:	d007      	beq.n	262 <errata_31+0x3a>
    return false;
 252:	2000      	movs	r0, #0
 254:	4770      	bx	lr
 256:	2000      	movs	r0, #0
 258:	4770      	bx	lr
            return true;
 25a:	2001      	movs	r0, #1
 25c:	4770      	bx	lr
            return true;
 25e:	2001      	movs	r0, #1
 260:	4770      	bx	lr
            return true;
 262:	2001      	movs	r0, #1
}
 264:	4770      	bx	lr
 266:	bf00      	nop
 268:	f0000fe0 	.word	0xf0000fe0
 26c:	f0000fe4 	.word	0xf0000fe4
 270:	f0000fe8 	.word	0xf0000fe8

00000274 <errata_32>:

static bool errata_32(void)
{
    if ((((*(uint32_t *)0xF0000FE0) & 0x000000FF) == 0x6) && (((*(uint32_t *)0xF0000FE4) & 0x0000000F) == 0x0)){
 274:	4b0b      	ldr	r3, [pc, #44]	; (2a4 <errata_32+0x30>)
 276:	781b      	ldrb	r3, [r3, #0]
 278:	2b06      	cmp	r3, #6
 27a:	d001      	beq.n	280 <errata_32+0xc>
        if (((*(uint32_t *)0xF0000FE8) & 0x000000F0) == 0x30){
            return true;
        }
    }

    return false;
 27c:	2000      	movs	r0, #0
 27e:	4770      	bx	lr
    if ((((*(uint32_t *)0xF0000FE0) & 0x000000FF) == 0x6) && (((*(uint32_t *)0xF0000FE4) & 0x0000000F) == 0x0)){
 280:	4b09      	ldr	r3, [pc, #36]	; (2a8 <errata_32+0x34>)
 282:	681b      	ldr	r3, [r3, #0]
 284:	f013 0f0f 	tst.w	r3, #15
 288:	d107      	bne.n	29a <errata_32+0x26>
        if (((*(uint32_t *)0xF0000FE8) & 0x000000F0) == 0x30){
 28a:	4b08      	ldr	r3, [pc, #32]	; (2ac <errata_32+0x38>)
 28c:	681b      	ldr	r3, [r3, #0]
 28e:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
 292:	2b30      	cmp	r3, #48	; 0x30
 294:	d003      	beq.n	29e <errata_32+0x2a>
    return false;
 296:	2000      	movs	r0, #0
 298:	4770      	bx	lr
 29a:	2000      	movs	r0, #0
 29c:	4770      	bx	lr
            return true;
 29e:	2001      	movs	r0, #1
}
 2a0:	4770      	bx	lr
 2a2:	bf00      	nop
 2a4:	f0000fe0 	.word	0xf0000fe0
 2a8:	f0000fe4 	.word	0xf0000fe4
 2ac:	f0000fe8 	.word	0xf0000fe8

000002b0 <errata_36>:

static bool errata_36(void)
{
    if ((((*(uint32_t *)0xF0000FE0) & 0x000000FF) == 0x6) && (((*(uint32_t *)0xF0000FE4) & 0x0000000F) == 0x0)){
 2b0:	4b0f      	ldr	r3, [pc, #60]	; (2f0 <errata_36+0x40>)
 2b2:	781b      	ldrb	r3, [r3, #0]
 2b4:	2b06      	cmp	r3, #6
 2b6:	d001      	beq.n	2bc <errata_36+0xc>
        if (((*(uint32_t *)0xF0000FE8) & 0x000000F0) == 0x50){
            return true;
        }
    }

    return false;
 2b8:	2000      	movs	r0, #0
 2ba:	4770      	bx	lr
    if ((((*(uint32_t *)0xF0000FE0) & 0x000000FF) == 0x6) && (((*(uint32_t *)0xF0000FE4) & 0x0000000F) == 0x0)){
 2bc:	4b0d      	ldr	r3, [pc, #52]	; (2f4 <errata_36+0x44>)
 2be:	681b      	ldr	r3, [r3, #0]
 2c0:	f013 0f0f 	tst.w	r3, #15
 2c4:	d10b      	bne.n	2de <errata_36+0x2e>
        if (((*(uint32_t *)0xF0000FE8) & 0x000000F0) == 0x30){
 2c6:	4b0c      	ldr	r3, [pc, #48]	; (2f8 <errata_36+0x48>)
 2c8:	681b      	ldr	r3, [r3, #0]
 2ca:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
 2ce:	2b30      	cmp	r3, #48	; 0x30
 2d0:	d007      	beq.n	2e2 <errata_36+0x32>
        if (((*(uint32_t *)0xF0000FE8) & 0x000000F0) == 0x40){
 2d2:	2b40      	cmp	r3, #64	; 0x40
 2d4:	d007      	beq.n	2e6 <errata_36+0x36>
        if (((*(uint32_t *)0xF0000FE8) & 0x000000F0) == 0x50){
 2d6:	2b50      	cmp	r3, #80	; 0x50
 2d8:	d007      	beq.n	2ea <errata_36+0x3a>
    return false;
 2da:	2000      	movs	r0, #0
 2dc:	4770      	bx	lr
 2de:	2000      	movs	r0, #0
 2e0:	4770      	bx	lr
            return true;
 2e2:	2001      	movs	r0, #1
 2e4:	4770      	bx	lr
            return true;
 2e6:	2001      	movs	r0, #1
 2e8:	4770      	bx	lr
            return true;
 2ea:	2001      	movs	r0, #1
}
 2ec:	4770      	bx	lr
 2ee:	bf00      	nop
 2f0:	f0000fe0 	.word	0xf0000fe0
 2f4:	f0000fe4 	.word	0xf0000fe4
 2f8:	f0000fe8 	.word	0xf0000fe8

000002fc <errata_37>:

static bool errata_37(void)
{
    if ((((*(uint32_t *)0xF0000FE0) & 0x000000FF) == 0x6) && (((*(uint32_t *)0xF0000FE4) & 0x0000000F) == 0x0)){
 2fc:	4b0b      	ldr	r3, [pc, #44]	; (32c <errata_37+0x30>)
 2fe:	781b      	ldrb	r3, [r3, #0]
 300:	2b06      	cmp	r3, #6
 302:	d001      	beq.n	308 <errata_37+0xc>
        if (((*(uint32_t *)0xF0000FE8) & 0x000000F0) == 0x30){
            return true;
        }
    }

    return false;
 304:	2000      	movs	r0, #0
 306:	4770      	bx	lr
    if ((((*(uint32_t *)0xF0000FE0) & 0x000000FF) == 0x6) && (((*(uint32_t *)0xF0000FE4) & 0x0000000F) == 0x0)){
 308:	4b09      	ldr	r3, [pc, #36]	; (330 <errata_37+0x34>)
 30a:	681b      	ldr	r3, [r3, #0]
 30c:	f013 0f0f 	tst.w	r3, #15
 310:	d107      	bne.n	322 <errata_37+0x26>
        if (((*(uint32_t *)0xF0000FE8) & 0x000000F0) == 0x30){
 312:	4b08      	ldr	r3, [pc, #32]	; (334 <errata_37+0x38>)
 314:	681b      	ldr	r3, [r3, #0]
 316:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
 31a:	2b30      	cmp	r3, #48	; 0x30
 31c:	d003      	beq.n	326 <errata_37+0x2a>
    return false;
 31e:	2000      	movs	r0, #0
 320:	4770      	bx	lr
 322:	2000      	movs	r0, #0
 324:	4770      	bx	lr
            return true;
 326:	2001      	movs	r0, #1
}
 328:	4770      	bx	lr
 32a:	bf00      	nop
 32c:	f0000fe0 	.word	0xf0000fe0
 330:	f0000fe4 	.word	0xf0000fe4
 334:	f0000fe8 	.word	0xf0000fe8

00000338 <errata_57>:

static bool errata_57(void)
{
    if ((((*(uint32_t *)0xF0000FE0) & 0x000000FF) == 0x6) && (((*(uint32_t *)0xF0000FE4) & 0x0000000F) == 0x0)){
 338:	4b0b      	ldr	r3, [pc, #44]	; (368 <errata_57+0x30>)
 33a:	781b      	ldrb	r3, [r3, #0]
 33c:	2b06      	cmp	r3, #6
 33e:	d001      	beq.n	344 <errata_57+0xc>
        if (((*(uint32_t *)0xF0000FE8) & 0x000000F0) == 0x30){
            return true;
        }
    }

    return false;
 340:	2000      	movs	r0, #0
 342:	4770      	bx	lr
    if ((((*(uint32_t *)0xF0000FE0) & 0x000000FF) == 0x6) && (((*(uint32_t *)0xF0000FE4) & 0x0000000F) == 0x0)){
 344:	4b09      	ldr	r3, [pc, #36]	; (36c <errata_57+0x34>)
 346:	681b      	ldr	r3, [r3, #0]
 348:	f013 0f0f 	tst.w	r3, #15
 34c:	d107      	bne.n	35e <errata_57+0x26>
        if (((*(uint32_t *)0xF0000FE8) & 0x000000F0) == 0x30){
 34e:	4b08      	ldr	r3, [pc, #32]	; (370 <errata_57+0x38>)
 350:	681b      	ldr	r3, [r3, #0]
 352:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
 356:	2b30      	cmp	r3, #48	; 0x30
 358:	d003      	beq.n	362 <errata_57+0x2a>
    return false;
 35a:	2000      	movs	r0, #0
 35c:	4770      	bx	lr
 35e:	2000      	movs	r0, #0
 360:	4770      	bx	lr
            return true;
 362:	2001      	movs	r0, #1
}
 364:	4770      	bx	lr
 366:	bf00      	nop
 368:	f0000fe0 	.word	0xf0000fe0
 36c:	f0000fe4 	.word	0xf0000fe4
 370:	f0000fe8 	.word	0xf0000fe8

00000374 <errata_66>:

static bool errata_66(void)
{
    if ((((*(uint32_t *)0xF0000FE0) & 0x000000FF) == 0x6) && (((*(uint32_t *)0xF0000FE4) & 0x0000000F) == 0x0)){
 374:	4b0b      	ldr	r3, [pc, #44]	; (3a4 <errata_66+0x30>)
 376:	781b      	ldrb	r3, [r3, #0]
 378:	2b06      	cmp	r3, #6
 37a:	d001      	beq.n	380 <errata_66+0xc>
        if (((*(uint32_t *)0xF0000FE8) & 0x000000F0) == 0x50){
            return true;
        }
    }

    return false;
 37c:	2000      	movs	r0, #0
 37e:	4770      	bx	lr
    if ((((*(uint32_t *)0xF0000FE0) & 0x000000FF) == 0x6) && (((*(uint32_t *)0xF0000FE4) & 0x0000000F) == 0x0)){
 380:	4b09      	ldr	r3, [pc, #36]	; (3a8 <errata_66+0x34>)
 382:	681b      	ldr	r3, [r3, #0]
 384:	f013 0f0f 	tst.w	r3, #15
 388:	d107      	bne.n	39a <errata_66+0x26>
        if (((*(uint32_t *)0xF0000FE8) & 0x000000F0) == 0x50){
 38a:	4b08      	ldr	r3, [pc, #32]	; (3ac <errata_66+0x38>)
 38c:	681b      	ldr	r3, [r3, #0]
 38e:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
 392:	2b50      	cmp	r3, #80	; 0x50
 394:	d003      	beq.n	39e <errata_66+0x2a>
    return false;
 396:	2000      	movs	r0, #0
 398:	4770      	bx	lr
 39a:	2000      	movs	r0, #0
 39c:	4770      	bx	lr
            return true;
 39e:	2001      	movs	r0, #1
}
 3a0:	4770      	bx	lr
 3a2:	bf00      	nop
 3a4:	f0000fe0 	.word	0xf0000fe0
 3a8:	f0000fe4 	.word	0xf0000fe4
 3ac:	f0000fe8 	.word	0xf0000fe8

000003b0 <errata_108>:


static bool errata_108(void)
{
    if ((((*(uint32_t *)0xF0000FE0) & 0x000000FF) == 0x6) && (((*(uint32_t *)0xF0000FE4) & 0x0000000F) == 0x0)){
 3b0:	4b0f      	ldr	r3, [pc, #60]	; (3f0 <errata_108+0x40>)
 3b2:	781b      	ldrb	r3, [r3, #0]
 3b4:	2b06      	cmp	r3, #6
 3b6:	d001      	beq.n	3bc <errata_108+0xc>
        if (((*(uint32_t *)0xF0000FE8) & 0x000000F0) == 0x50){
            return true;
        }
    }

    return false;
 3b8:	2000      	movs	r0, #0
 3ba:	4770      	bx	lr
    if ((((*(uint32_t *)0xF0000FE0) & 0x000000FF) == 0x6) && (((*(uint32_t *)0xF0000FE4) & 0x0000000F) == 0x0)){
 3bc:	4b0d      	ldr	r3, [pc, #52]	; (3f4 <errata_108+0x44>)
 3be:	681b      	ldr	r3, [r3, #0]
 3c0:	f013 0f0f 	tst.w	r3, #15
 3c4:	d10b      	bne.n	3de <errata_108+0x2e>
        if (((*(uint32_t *)0xF0000FE8) & 0x000000F0) == 0x30){
 3c6:	4b0c      	ldr	r3, [pc, #48]	; (3f8 <errata_108+0x48>)
 3c8:	681b      	ldr	r3, [r3, #0]
 3ca:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
 3ce:	2b30      	cmp	r3, #48	; 0x30
 3d0:	d007      	beq.n	3e2 <errata_108+0x32>
        if (((*(uint32_t *)0xF0000FE8) & 0x000000F0) == 0x40){
 3d2:	2b40      	cmp	r3, #64	; 0x40
 3d4:	d007      	beq.n	3e6 <errata_108+0x36>
        if (((*(uint32_t *)0xF0000FE8) & 0x000000F0) == 0x50){
 3d6:	2b50      	cmp	r3, #80	; 0x50
 3d8:	d007      	beq.n	3ea <errata_108+0x3a>
    return false;
 3da:	2000      	movs	r0, #0
 3dc:	4770      	bx	lr
 3de:	2000      	movs	r0, #0
 3e0:	4770      	bx	lr
            return true;
 3e2:	2001      	movs	r0, #1
 3e4:	4770      	bx	lr
            return true;
 3e6:	2001      	movs	r0, #1
 3e8:	4770      	bx	lr
            return true;
 3ea:	2001      	movs	r0, #1
}
 3ec:	4770      	bx	lr
 3ee:	bf00      	nop
 3f0:	f0000fe0 	.word	0xf0000fe0
 3f4:	f0000fe4 	.word	0xf0000fe4
 3f8:	f0000fe8 	.word	0xf0000fe8

000003fc <SystemCoreClockUpdate>:
    SystemCoreClock = __SYSTEM_CLOCK_64M;
 3fc:	4b01      	ldr	r3, [pc, #4]	; (404 <SystemCoreClockUpdate+0x8>)
 3fe:	4a02      	ldr	r2, [pc, #8]	; (408 <SystemCoreClockUpdate+0xc>)
 400:	601a      	str	r2, [r3, #0]
}
 402:	4770      	bx	lr
 404:	200000e4 	.word	0x200000e4
 408:	03d09000 	.word	0x03d09000

0000040c <SystemInit>:
{
 40c:	b508      	push	{r3, lr}
    if (errata_16()){
 40e:	f7ff feed 	bl	1ec <errata_16>
 412:	b110      	cbz	r0, 41a <SystemInit+0xe>
        *(volatile uint32_t *)0x4007C074 = 3131961357ul;
 414:	4b60      	ldr	r3, [pc, #384]	; (598 <SystemInit+0x18c>)
 416:	4a61      	ldr	r2, [pc, #388]	; (59c <SystemInit+0x190>)
 418:	601a      	str	r2, [r3, #0]
    if (errata_31()){
 41a:	f7ff ff05 	bl	228 <errata_31>
 41e:	b128      	cbz	r0, 42c <SystemInit+0x20>
        *(volatile uint32_t *)0x4000053C = ((*(volatile uint32_t *)0x10000244) & 0x0000E000) >> 13;
 420:	4b5f      	ldr	r3, [pc, #380]	; (5a0 <SystemInit+0x194>)
 422:	681b      	ldr	r3, [r3, #0]
 424:	f3c3 3342 	ubfx	r3, r3, #13, #3
 428:	4a5e      	ldr	r2, [pc, #376]	; (5a4 <SystemInit+0x198>)
 42a:	6013      	str	r3, [r2, #0]
    if (errata_32()){
 42c:	f7ff ff22 	bl	274 <errata_32>
 430:	b120      	cbz	r0, 43c <SystemInit+0x30>
        CoreDebug->DEMCR &= ~CoreDebug_DEMCR_TRCENA_Msk;
 432:	4a5d      	ldr	r2, [pc, #372]	; (5a8 <SystemInit+0x19c>)
 434:	68d3      	ldr	r3, [r2, #12]
 436:	f023 7380 	bic.w	r3, r3, #16777216	; 0x1000000
 43a:	60d3      	str	r3, [r2, #12]
    if (errata_36()){
 43c:	f7ff ff38 	bl	2b0 <errata_36>
 440:	b140      	cbz	r0, 454 <SystemInit+0x48>
        NRF_CLOCK->EVENTS_DONE = 0;
 442:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 446:	2200      	movs	r2, #0
 448:	f8c3 210c 	str.w	r2, [r3, #268]	; 0x10c
        NRF_CLOCK->EVENTS_CTTO = 0;
 44c:	f8c3 2110 	str.w	r2, [r3, #272]	; 0x110
        NRF_CLOCK->CTIV = 0;
 450:	f8c3 2538 	str.w	r2, [r3, #1336]	; 0x538
    if (errata_37()){
 454:	f7ff ff52 	bl	2fc <errata_37>
 458:	b110      	cbz	r0, 460 <SystemInit+0x54>
        *(volatile uint32_t *)0x400005A0 = 0x3;
 45a:	4b54      	ldr	r3, [pc, #336]	; (5ac <SystemInit+0x1a0>)
 45c:	2203      	movs	r2, #3
 45e:	601a      	str	r2, [r3, #0]
    if (errata_57()){
 460:	f7ff ff6a 	bl	338 <errata_57>
 464:	b158      	cbz	r0, 47e <SystemInit+0x72>
        *(volatile uint32_t *)0x40005610 = 0x00000005;
 466:	4b52      	ldr	r3, [pc, #328]	; (5b0 <SystemInit+0x1a4>)
 468:	2205      	movs	r2, #5
 46a:	601a      	str	r2, [r3, #0]
        *(volatile uint32_t *)0x40005688 = 0x00000001;
 46c:	3378      	adds	r3, #120	; 0x78
 46e:	2201      	movs	r2, #1
 470:	601a      	str	r2, [r3, #0]
        *(volatile uint32_t *)0x40005618 = 0x00000000;
 472:	3b70      	subs	r3, #112	; 0x70
 474:	2200      	movs	r2, #0
 476:	601a      	str	r2, [r3, #0]
        *(volatile uint32_t *)0x40005614 = 0x0000003F;
 478:	3b04      	subs	r3, #4
 47a:	223f      	movs	r2, #63	; 0x3f
 47c:	601a      	str	r2, [r3, #0]
    if (errata_66()){
 47e:	f7ff ff79 	bl	374 <errata_66>
 482:	2800      	cmp	r0, #0
 484:	d046      	beq.n	514 <SystemInit+0x108>
        NRF_TEMP->A0 = NRF_FICR->TEMP.A0;
 486:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 48a:	f8d2 1404 	ldr.w	r1, [r2, #1028]	; 0x404
 48e:	4b49      	ldr	r3, [pc, #292]	; (5b4 <SystemInit+0x1a8>)
 490:	f8c3 1520 	str.w	r1, [r3, #1312]	; 0x520
        NRF_TEMP->A1 = NRF_FICR->TEMP.A1;
 494:	f8d2 1408 	ldr.w	r1, [r2, #1032]	; 0x408
 498:	f8c3 1524 	str.w	r1, [r3, #1316]	; 0x524
        NRF_TEMP->A2 = NRF_FICR->TEMP.A2;
 49c:	f8d2 140c 	ldr.w	r1, [r2, #1036]	; 0x40c
 4a0:	f8c3 1528 	str.w	r1, [r3, #1320]	; 0x528
        NRF_TEMP->A3 = NRF_FICR->TEMP.A3;
 4a4:	f8d2 1410 	ldr.w	r1, [r2, #1040]	; 0x410
 4a8:	f8c3 152c 	str.w	r1, [r3, #1324]	; 0x52c
        NRF_TEMP->A4 = NRF_FICR->TEMP.A4;
 4ac:	f8d2 1414 	ldr.w	r1, [r2, #1044]	; 0x414
 4b0:	f8c3 1530 	str.w	r1, [r3, #1328]	; 0x530
        NRF_TEMP->A5 = NRF_FICR->TEMP.A5;
 4b4:	f8d2 1418 	ldr.w	r1, [r2, #1048]	; 0x418
 4b8:	f8c3 1534 	str.w	r1, [r3, #1332]	; 0x534
        NRF_TEMP->B0 = NRF_FICR->TEMP.B0;
 4bc:	f8d2 141c 	ldr.w	r1, [r2, #1052]	; 0x41c
 4c0:	f8c3 1540 	str.w	r1, [r3, #1344]	; 0x540
        NRF_TEMP->B1 = NRF_FICR->TEMP.B1;
 4c4:	f8d2 1420 	ldr.w	r1, [r2, #1056]	; 0x420
 4c8:	f8c3 1544 	str.w	r1, [r3, #1348]	; 0x544
        NRF_TEMP->B2 = NRF_FICR->TEMP.B2;
 4cc:	f8d2 1424 	ldr.w	r1, [r2, #1060]	; 0x424
 4d0:	f8c3 1548 	str.w	r1, [r3, #1352]	; 0x548
        NRF_TEMP->B3 = NRF_FICR->TEMP.B3;
 4d4:	f8d2 1428 	ldr.w	r1, [r2, #1064]	; 0x428
 4d8:	f8c3 154c 	str.w	r1, [r3, #1356]	; 0x54c
        NRF_TEMP->B4 = NRF_FICR->TEMP.B4;
 4dc:	f8d2 142c 	ldr.w	r1, [r2, #1068]	; 0x42c
 4e0:	f8c3 1550 	str.w	r1, [r3, #1360]	; 0x550
        NRF_TEMP->B5 = NRF_FICR->TEMP.B5;
 4e4:	f8d2 1430 	ldr.w	r1, [r2, #1072]	; 0x430
 4e8:	f8c3 1554 	str.w	r1, [r3, #1364]	; 0x554
        NRF_TEMP->T0 = NRF_FICR->TEMP.T0;
 4ec:	f8d2 1434 	ldr.w	r1, [r2, #1076]	; 0x434
 4f0:	f8c3 1560 	str.w	r1, [r3, #1376]	; 0x560
        NRF_TEMP->T1 = NRF_FICR->TEMP.T1;
 4f4:	f8d2 1438 	ldr.w	r1, [r2, #1080]	; 0x438
 4f8:	f8c3 1564 	str.w	r1, [r3, #1380]	; 0x564
        NRF_TEMP->T2 = NRF_FICR->TEMP.T2;
 4fc:	f8d2 143c 	ldr.w	r1, [r2, #1084]	; 0x43c
 500:	f8c3 1568 	str.w	r1, [r3, #1384]	; 0x568
        NRF_TEMP->T3 = NRF_FICR->TEMP.T3;
 504:	f8d2 1440 	ldr.w	r1, [r2, #1088]	; 0x440
 508:	f8c3 156c 	str.w	r1, [r3, #1388]	; 0x56c
        NRF_TEMP->T4 = NRF_FICR->TEMP.T4;
 50c:	f8d2 2444 	ldr.w	r2, [r2, #1092]	; 0x444
 510:	f8c3 2570 	str.w	r2, [r3, #1392]	; 0x570
    if (errata_108()){
 514:	f7ff ff4c 	bl	3b0 <errata_108>
 518:	b128      	cbz	r0, 526 <SystemInit+0x11a>
        *(volatile uint32_t *)0x40000EE4 = *(volatile uint32_t *)0x10000258 & 0x0000004F;
 51a:	4b27      	ldr	r3, [pc, #156]	; (5b8 <SystemInit+0x1ac>)
 51c:	681b      	ldr	r3, [r3, #0]
 51e:	f003 034f 	and.w	r3, r3, #79	; 0x4f
 522:	4a26      	ldr	r2, [pc, #152]	; (5bc <SystemInit+0x1b0>)
 524:	6013      	str	r3, [r2, #0]
        if ((NRF_UICR->NFCPINS & UICR_NFCPINS_PROTECT_Msk) == (UICR_NFCPINS_PROTECT_NFC << UICR_NFCPINS_PROTECT_Pos)){
 526:	f04f 2310 	mov.w	r3, #268439552	; 0x10001000
 52a:	f8d3 320c 	ldr.w	r3, [r3, #524]	; 0x20c
 52e:	f013 0f01 	tst.w	r3, #1
 532:	d104      	bne.n	53e <SystemInit+0x132>
    SystemCoreClockUpdate();
 534:	f7ff ff62 	bl	3fc <SystemCoreClockUpdate>
    NVIC_Relocate();
 538:	f000 f860 	bl	5fc <NVIC_Relocate>
}
 53c:	bd08      	pop	{r3, pc}
            NRF_NVMC->CONFIG = NVMC_CONFIG_WEN_Wen << NVMC_CONFIG_WEN_Pos;
 53e:	4b20      	ldr	r3, [pc, #128]	; (5c0 <SystemInit+0x1b4>)
 540:	2201      	movs	r2, #1
 542:	f8c3 2504 	str.w	r2, [r3, #1284]	; 0x504
            while (NRF_NVMC->READY == NVMC_READY_READY_Busy){}
 546:	4b1e      	ldr	r3, [pc, #120]	; (5c0 <SystemInit+0x1b4>)
 548:	f8d3 3400 	ldr.w	r3, [r3, #1024]	; 0x400
 54c:	2b00      	cmp	r3, #0
 54e:	d0fa      	beq.n	546 <SystemInit+0x13a>
            NRF_UICR->NFCPINS &= ~UICR_NFCPINS_PROTECT_Msk;
 550:	f04f 2210 	mov.w	r2, #268439552	; 0x10001000
 554:	f8d2 320c 	ldr.w	r3, [r2, #524]	; 0x20c
 558:	f023 0301 	bic.w	r3, r3, #1
 55c:	f8c2 320c 	str.w	r3, [r2, #524]	; 0x20c
            while (NRF_NVMC->READY == NVMC_READY_READY_Busy){}
 560:	4b17      	ldr	r3, [pc, #92]	; (5c0 <SystemInit+0x1b4>)
 562:	f8d3 3400 	ldr.w	r3, [r3, #1024]	; 0x400
 566:	2b00      	cmp	r3, #0
 568:	d0fa      	beq.n	560 <SystemInit+0x154>
            NRF_NVMC->CONFIG = NVMC_CONFIG_WEN_Ren << NVMC_CONFIG_WEN_Pos;
 56a:	4b15      	ldr	r3, [pc, #84]	; (5c0 <SystemInit+0x1b4>)
 56c:	2200      	movs	r2, #0
 56e:	f8c3 2504 	str.w	r2, [r3, #1284]	; 0x504
            while (NRF_NVMC->READY == NVMC_READY_READY_Busy){}
 572:	4b13      	ldr	r3, [pc, #76]	; (5c0 <SystemInit+0x1b4>)
 574:	f8d3 3400 	ldr.w	r3, [r3, #1024]	; 0x400
 578:	2b00      	cmp	r3, #0
 57a:	d0fa      	beq.n	572 <SystemInit+0x166>
 57c:	f3bf 8f4f 	dsb	sy
                           (SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) |
 580:	4910      	ldr	r1, [pc, #64]	; (5c4 <SystemInit+0x1b8>)
 582:	68ca      	ldr	r2, [r1, #12]
 584:	f402 62e0 	and.w	r2, r2, #1792	; 0x700
  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
 588:	4b0f      	ldr	r3, [pc, #60]	; (5c8 <SystemInit+0x1bc>)
 58a:	4313      	orrs	r3, r2
 58c:	60cb      	str	r3, [r1, #12]
 58e:	f3bf 8f4f 	dsb	sy
    __NOP();
 592:	bf00      	nop
 594:	e7fd      	b.n	592 <SystemInit+0x186>
 596:	bf00      	nop
 598:	4007c074 	.word	0x4007c074
 59c:	baadf00d 	.word	0xbaadf00d
 5a0:	10000244 	.word	0x10000244
 5a4:	4000053c 	.word	0x4000053c
 5a8:	e000edf0 	.word	0xe000edf0
 5ac:	400005a0 	.word	0x400005a0
 5b0:	40005610 	.word	0x40005610
 5b4:	4000c000 	.word	0x4000c000
 5b8:	10000258 	.word	0x10000258
 5bc:	40000ee4 	.word	0x40000ee4
 5c0:	4001e000 	.word	0x4001e000
 5c4:	e000ed00 	.word	0xe000ed00
 5c8:	05fa0004 	.word	0x05fa0004

000005cc <_start>:

/*
 * Rudimentary startup function.
 */
void _start(void)
{
 5cc:	b508      	push	{r3, lr}
#if !MYNEWT_VAL(OS_SCHEDULING)
    int rc;

    rc = main(0, NULL);
 5ce:	2100      	movs	r1, #0
 5d0:	4608      	mov	r0, r1
 5d2:	f000 f803 	bl	5dc <main>
#define EXIT_SUCCESS	0
#define EXIT_FAILURE	1
__extern void _exit(int s);
__extern_inline void exit(int err)
{
	_exit(err);
 5d6:	f000 f82b 	bl	630 <_exit>

000005da <_init>:
}

void
_init(void)
{
}
 5da:	4770      	bx	lr

000005dc <main>:
void *_estack;  //  End of stack, defined in Linker Script.
extern const struct flash_area sysflash_map_dflt[];  //  Contains addresses of flash sections. Defined in bin/targets/bluepill_boot/generated/src/bluepill_boot-sysflash.c

int
main(void)
{
 5dc:	b508      	push	{r3, lr}
    //  This is a stub bootloader for Blue Pill.  We jump straight into the application.
    //  This simple bootloader allows the application to take up more ROM space.
    hal_bsp_init();
 5de:	f000 f807 	bl	5f0 <hal_bsp_init>

    //  img_start points to the nRF52 Vector Table for the app...
    //  First word contains initial MSP value (estack = end of RAM)
    //  Second word contains address of entry point (Reset_Handler = 0x0800112d)
    void *img_start = (void *) (
        sysflash_map_dflt[1].fa_off  //  Offset of FLASH_AREA_IMAGE_0 (application image): 0x00008000
 5e2:	4b02      	ldr	r3, [pc, #8]	; (5ec <main+0x10>)
 5e4:	6918      	ldr	r0, [r3, #16]
        + 0x20                       //  Size of Mynewt image header
    );  //  Equals 0x00008020 (__isr_vector)

    //  Jump to Reset_Handler of the application. Uses first word and second word of img_start.
    hal_system_start(img_start);
 5e6:	3020      	adds	r0, #32
 5e8:	f000 f825 	bl	636 <hal_system_start>
 5ec:	00000b00 	.word	0x00000b00

000005f0 <hal_bsp_init>:
    return cfg_pri;
}

void
hal_bsp_init(void)
{
 5f0:	b508      	push	{r3, lr}
    /* Make sure system clocks have started */
    hal_system_clock_start();
 5f2:	f7ff fdd5 	bl	1a0 <hal_system_clock_start>

    /* Create all available nRF52840 peripherals */
    nrf52_periph_create();
 5f6:	f000 f83d 	bl	674 <nrf52_periph_create>
}
 5fa:	bd08      	pop	{r3, pc}

000005fc <NVIC_Relocate>:
     * designated in the linker script.
     */
    current_location = (uint32_t *)&__isr_vector;
    new_location = (uint32_t *)&__vector_tbl_reloc__;

    if (new_location != current_location) {
 5fc:	4a09      	ldr	r2, [pc, #36]	; (624 <NVIC_Relocate+0x28>)
 5fe:	4b0a      	ldr	r3, [pc, #40]	; (628 <NVIC_Relocate+0x2c>)
 600:	429a      	cmp	r2, r3
 602:	d00a      	beq.n	61a <NVIC_Relocate+0x1e>
        for (i = 0; i < NVIC_NUM_VECTORS; i++) {
 604:	2300      	movs	r3, #0
 606:	e006      	b.n	616 <NVIC_Relocate+0x1a>
            new_location[i] = current_location[i];
 608:	4a07      	ldr	r2, [pc, #28]	; (628 <NVIC_Relocate+0x2c>)
 60a:	f852 1023 	ldr.w	r1, [r2, r3, lsl #2]
 60e:	4a05      	ldr	r2, [pc, #20]	; (624 <NVIC_Relocate+0x28>)
 610:	f842 1023 	str.w	r1, [r2, r3, lsl #2]
        for (i = 0; i < NVIC_NUM_VECTORS; i++) {
 614:	3301      	adds	r3, #1
 616:	2b35      	cmp	r3, #53	; 0x35
 618:	ddf6      	ble.n	608 <NVIC_Relocate+0xc>
    }

    /* Set VTOR except for M0 */
#if ((__CORTEX_M == 0) && (__VTOR_PRESENT == 0))
#else
    SCB->VTOR = (uint32_t)&__vector_tbl_reloc__;
 61a:	4a02      	ldr	r2, [pc, #8]	; (624 <NVIC_Relocate+0x28>)
 61c:	4b03      	ldr	r3, [pc, #12]	; (62c <NVIC_Relocate+0x30>)
 61e:	609a      	str	r2, [r3, #8]
#endif
}
 620:	4770      	bx	lr
 622:	bf00      	nop
 624:	20000000 	.word	0x20000000
 628:	00000000 	.word	0x00000000
 62c:	e000ed00 	.word	0xe000ed00

00000630 <_exit>:

void _exit(int status);

void
_exit(int status)
{
 630:	b508      	push	{r3, lr}
    hal_system_reset();
 632:	f7ff fd9f 	bl	174 <hal_system_reset>

00000636 <hal_system_start>:
                  /* 1st word is stack pointer */
                  "    msr  msp, %0       \n"
                  /* 2nd word is a reset handler (image entry) */
                  "    bx   %1            \n"
                  : /* no output */
                  : "r" (img_data[0]), "r" (img_data[1]));
 636:	6803      	ldr	r3, [r0, #0]
 638:	6842      	ldr	r2, [r0, #4]
    asm volatile (".syntax unified        \n"
 63a:	f383 8808 	msr	MSP, r3
 63e:	4710      	bx	r2

00000640 <nrf52_periph_create_timers>:
};
#endif

static void
nrf52_periph_create_timers(void)
{
 640:	b508      	push	{r3, lr}
    int rc;

    (void)rc;

#if MYNEWT_VAL(TIMER_0)
    rc = hal_timer_init(0, NULL);
 642:	2100      	movs	r1, #0
 644:	4608      	mov	r0, r1
 646:	f000 f907 	bl	858 <hal_timer_init>
    assert(rc == 0);
 64a:	b920      	cbnz	r0, 656 <nrf52_periph_create_timers+0x16>
    rc = hal_timer_init(5, NULL);
    assert(rc == 0);
#endif

#if MYNEWT_VAL(OS_CPUTIME_TIMER_NUM) >= 0
    rc = os_cputime_init(MYNEWT_VAL(OS_CPUTIME_FREQ));
 64c:	4808      	ldr	r0, [pc, #32]	; (670 <nrf52_periph_create_timers+0x30>)
 64e:	f000 f9cd 	bl	9ec <os_cputime_init>
    assert(rc == 0);
 652:	b930      	cbnz	r0, 662 <nrf52_periph_create_timers+0x22>
#endif
}
 654:	bd08      	pop	{r3, pc}
    assert(rc == 0);
 656:	2300      	movs	r3, #0
 658:	461a      	mov	r2, r3
 65a:	4619      	mov	r1, r3
 65c:	4618      	mov	r0, r3
 65e:	f000 f9a7 	bl	9b0 <__assert_func>
    assert(rc == 0);
 662:	2300      	movs	r3, #0
 664:	461a      	mov	r2, r3
 666:	4619      	mov	r1, r3
 668:	4618      	mov	r0, r3
 66a:	f000 f9a1 	bl	9b0 <__assert_func>
 66e:	bf00      	nop
 670:	000f4240 	.word	0x000f4240

00000674 <nrf52_periph_create>:
#endif
}

void
nrf52_periph_create(void)
{
 674:	b508      	push	{r3, lr}
    nrf52_periph_create_timers();
 676:	f7ff ffe3 	bl	640 <nrf52_periph_create_timers>
    nrf52_periph_create_trng();
    nrf52_periph_create_crypto();
    nrf52_periph_create_uart();
    nrf52_periph_create_i2c();
    nrf52_periph_create_spi();
}
 67a:	bd08      	pop	{r3, pc}

0000067c <nrf_read_timer_cntr>:
nrf_read_timer_cntr(NRF_TIMER_Type *hwtimer)
{
    uint32_t tcntr;

    /* Force a capture of the timer into 'cntr' capture channel; read it */
    hwtimer->TASKS_CAPTURE[NRF_TIMER_CC_READ] = 1;
 67c:	2301      	movs	r3, #1
 67e:	6483      	str	r3, [r0, #72]	; 0x48
    tcntr = hwtimer->CC[NRF_TIMER_CC_READ];
 680:	f8d0 0548 	ldr.w	r0, [r0, #1352]	; 0x548

    return tcntr;
}
 684:	4770      	bx	lr
	...

00000688 <nrf_timer_set_ocmp>:
 *
 * @param timer Pointer to timer.
 */
static void
nrf_timer_set_ocmp(struct nrf52_hal_timer *bsptimer, uint32_t expiry)
{
 688:	b538      	push	{r3, r4, r5, lr}
    uint32_t temp;
    uint32_t cntr;
    NRF_TIMER_Type *hwtimer;
    NRF_RTC_Type *rtctimer;

    if (bsptimer->tmr_rtc) {
 68a:	7883      	ldrb	r3, [r0, #2]
 68c:	b393      	cbz	r3, 6f4 <nrf_timer_set_ocmp+0x6c>
        rtctimer = (NRF_RTC_Type *)bsptimer->tmr_reg;
 68e:	6902      	ldr	r2, [r0, #16]
        rtctimer->INTENCLR = NRF_TIMER_INT_MASK(NRF_RTC_TIMER_CC_INT);
 690:	f44f 2380 	mov.w	r3, #262144	; 0x40000
 694:	f8c2 3308 	str.w	r3, [r2, #776]	; 0x308
        temp = bsptimer->tmr_cntr;
 698:	6843      	ldr	r3, [r0, #4]
        cntr = rtctimer->COUNTER;
 69a:	f8d2 4504 	ldr.w	r4, [r2, #1284]	; 0x504
        if (rtctimer->EVENTS_OVRFLW) {
 69e:	f8d2 5104 	ldr.w	r5, [r2, #260]	; 0x104
 6a2:	b11d      	cbz	r5, 6ac <nrf_timer_set_ocmp+0x24>
            temp += (1UL << 24);
 6a4:	f103 7380 	add.w	r3, r3, #16777216	; 0x1000000
            cntr = rtctimer->COUNTER;
 6a8:	f8d2 4504 	ldr.w	r4, [r2, #1284]	; 0x504
        }
        temp |= cntr;
 6ac:	4323      	orrs	r3, r4
        delta_t = (int32_t)(expiry - temp);
 6ae:	1acb      	subs	r3, r1, r3
         * The nrf documentation states that you must set the output
         * compare to 2 greater than the counter to guarantee an interrupt.
         * Since the counter can tick once while we check, we make sure
         * it is greater than 2.
         */
        if (delta_t < 3) {
 6b0:	2b02      	cmp	r3, #2
 6b2:	dc0e      	bgt.n	6d2 <nrf_timer_set_ocmp+0x4a>
            NVIC_SetPendingIRQ(bsptimer->tmr_irq_num);
 6b4:	7842      	ldrb	r2, [r0, #1]
 6b6:	b253      	sxtb	r3, r2
  if ((int32_t)(IRQn) >= 0)
 6b8:	2b00      	cmp	r3, #0
 6ba:	db15      	blt.n	6e8 <nrf_timer_set_ocmp+0x60>
    NVIC->ISPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
 6bc:	f002 021f 	and.w	r2, r2, #31
 6c0:	095b      	lsrs	r3, r3, #5
 6c2:	2101      	movs	r1, #1
 6c4:	fa01 f202 	lsl.w	r2, r1, r2
 6c8:	3340      	adds	r3, #64	; 0x40
 6ca:	491b      	ldr	r1, [pc, #108]	; (738 <nrf_timer_set_ocmp+0xb0>)
 6cc:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
 6d0:	e00a      	b.n	6e8 <nrf_timer_set_ocmp+0x60>
        } else  {
            if (delta_t < (1UL << 24)) {
 6d2:	f1b3 7f80 	cmp.w	r3, #16777216	; 0x1000000
 6d6:	d208      	bcs.n	6ea <nrf_timer_set_ocmp+0x62>
                rtctimer->CC[NRF_RTC_TIMER_CC_INT] = expiry & 0x00ffffff;
 6d8:	f021 417f 	bic.w	r1, r1, #4278190080	; 0xff000000
 6dc:	f8c2 1548 	str.w	r1, [r2, #1352]	; 0x548
            } else {
                /* CC too far ahead. Just make sure we set compare far ahead */
                rtctimer->CC[NRF_RTC_TIMER_CC_INT] = cntr + (1UL << 23);
            }
            rtctimer->INTENSET = NRF_TIMER_INT_MASK(NRF_RTC_TIMER_CC_INT);
 6e0:	f44f 2380 	mov.w	r3, #262144	; 0x40000
 6e4:	f8c2 3304 	str.w	r3, [r2, #772]	; 0x304
        /* Force interrupt to occur as we may have missed it */
        if ((int32_t)(nrf_read_timer_cntr(hwtimer) - expiry) >= 0) {
            NVIC_SetPendingIRQ(bsptimer->tmr_irq_num);
        }
    }
}
 6e8:	bd38      	pop	{r3, r4, r5, pc}
                rtctimer->CC[NRF_RTC_TIMER_CC_INT] = cntr + (1UL << 23);
 6ea:	f504 0400 	add.w	r4, r4, #8388608	; 0x800000
 6ee:	f8c2 4548 	str.w	r4, [r2, #1352]	; 0x548
 6f2:	e7f5      	b.n	6e0 <nrf_timer_set_ocmp+0x58>
 6f4:	460d      	mov	r5, r1
 6f6:	4604      	mov	r4, r0
        hwtimer = bsptimer->tmr_reg;
 6f8:	6900      	ldr	r0, [r0, #16]
        hwtimer->INTENCLR = NRF_TIMER_INT_MASK(NRF_TIMER_CC_INT);
 6fa:	f44f 2300 	mov.w	r3, #524288	; 0x80000
 6fe:	f8c0 3308 	str.w	r3, [r0, #776]	; 0x308
        hwtimer->CC[NRF_TIMER_CC_INT] = expiry;
 702:	f8c0 154c 	str.w	r1, [r0, #1356]	; 0x54c
        hwtimer->EVENTS_COMPARE[NRF_TIMER_CC_INT] = 0;
 706:	2200      	movs	r2, #0
 708:	f8c0 214c 	str.w	r2, [r0, #332]	; 0x14c
        hwtimer->INTENSET = NRF_TIMER_INT_MASK(NRF_TIMER_CC_INT);
 70c:	f8c0 3304 	str.w	r3, [r0, #772]	; 0x304
        if ((int32_t)(nrf_read_timer_cntr(hwtimer) - expiry) >= 0) {
 710:	f7ff ffb4 	bl	67c <nrf_read_timer_cntr>
 714:	1b40      	subs	r0, r0, r5
 716:	2800      	cmp	r0, #0
 718:	dbe6      	blt.n	6e8 <nrf_timer_set_ocmp+0x60>
            NVIC_SetPendingIRQ(bsptimer->tmr_irq_num);
 71a:	7862      	ldrb	r2, [r4, #1]
 71c:	b253      	sxtb	r3, r2
  if ((int32_t)(IRQn) >= 0)
 71e:	2b00      	cmp	r3, #0
 720:	dbe2      	blt.n	6e8 <nrf_timer_set_ocmp+0x60>
    NVIC->ISPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
 722:	f002 021f 	and.w	r2, r2, #31
 726:	095b      	lsrs	r3, r3, #5
 728:	2101      	movs	r1, #1
 72a:	fa01 f202 	lsl.w	r2, r1, r2
 72e:	3340      	adds	r3, #64	; 0x40
 730:	4901      	ldr	r1, [pc, #4]	; (738 <nrf_timer_set_ocmp+0xb0>)
 732:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
 736:	e7d7      	b.n	6e8 <nrf_timer_set_ocmp+0x60>
 738:	e000e100 	.word	0xe000e100

0000073c <nrf_timer_disable_ocmp>:

/* Disable output compare used for timer */
static void
nrf_timer_disable_ocmp(NRF_TIMER_Type *hwtimer)
{
    hwtimer->INTENCLR = NRF_TIMER_INT_MASK(NRF_TIMER_CC_INT);
 73c:	f44f 2300 	mov.w	r3, #524288	; 0x80000
 740:	f8c0 3308 	str.w	r3, [r0, #776]	; 0x308
}
 744:	4770      	bx	lr

00000746 <nrf_rtc_disable_ocmp>:

static void
nrf_rtc_disable_ocmp(NRF_RTC_Type *rtctimer)
{
    rtctimer->INTENCLR = NRF_TIMER_INT_MASK(NRF_RTC_TIMER_CC_INT);
 746:	f44f 2380 	mov.w	r3, #262144	; 0x40000
 74a:	f8c0 3308 	str.w	r3, [r0, #776]	; 0x308
}
 74e:	4770      	bx	lr

00000750 <hal_timer_read_bsptimer>:

static uint32_t
hal_timer_read_bsptimer(struct nrf52_hal_timer *bsptimer)
{
 750:	b430      	push	{r4, r5}
    uint32_t low32;
    uint32_t ctx;
    uint32_t tcntr;
    NRF_RTC_Type *rtctimer;

    rtctimer = (NRF_RTC_Type *)bsptimer->tmr_reg;
 752:	6902      	ldr	r2, [r0, #16]
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 754:	f3ef 8410 	mrs	r4, PRIMASK
  __ASM volatile ("cpsid i" : : : "memory");
 758:	b672      	cpsid	i
    __HAL_DISABLE_INTERRUPTS(ctx);
    tcntr = bsptimer->tmr_cntr;
 75a:	6841      	ldr	r1, [r0, #4]
    low32 = rtctimer->COUNTER;
 75c:	f8d2 3504 	ldr.w	r3, [r2, #1284]	; 0x504
    if (rtctimer->EVENTS_OVRFLW) {
 760:	f8d2 5104 	ldr.w	r5, [r2, #260]	; 0x104
 764:	b1ad      	cbz	r5, 792 <hal_timer_read_bsptimer+0x42>
        tcntr += (1UL << 24);
 766:	f101 7180 	add.w	r1, r1, #16777216	; 0x1000000
        bsptimer->tmr_cntr = tcntr;
 76a:	6041      	str	r1, [r0, #4]
        low32 = rtctimer->COUNTER;
 76c:	f8d2 3504 	ldr.w	r3, [r2, #1284]	; 0x504
        rtctimer->EVENTS_OVRFLW = 0;
 770:	2500      	movs	r5, #0
 772:	f8c2 5104 	str.w	r5, [r2, #260]	; 0x104
        NVIC_SetPendingIRQ(bsptimer->tmr_irq_num);
 776:	7840      	ldrb	r0, [r0, #1]
 778:	b242      	sxtb	r2, r0
  if ((int32_t)(IRQn) >= 0)
 77a:	42aa      	cmp	r2, r5
 77c:	db09      	blt.n	792 <hal_timer_read_bsptimer+0x42>
    NVIC->ISPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
 77e:	f000 001f 	and.w	r0, r0, #31
 782:	0952      	lsrs	r2, r2, #5
 784:	2501      	movs	r5, #1
 786:	fa05 f000 	lsl.w	r0, r5, r0
 78a:	3240      	adds	r2, #64	; 0x40
 78c:	4d04      	ldr	r5, [pc, #16]	; (7a0 <hal_timer_read_bsptimer+0x50>)
 78e:	f845 0022 	str.w	r0, [r5, r2, lsl #2]
    }
    tcntr |= low32;
 792:	ea43 0001 	orr.w	r0, r3, r1
    __HAL_ENABLE_INTERRUPTS(ctx);
 796:	b904      	cbnz	r4, 79a <hal_timer_read_bsptimer+0x4a>
  __ASM volatile ("cpsie i" : : : "memory");
 798:	b662      	cpsie	i

    return tcntr;
}
 79a:	bc30      	pop	{r4, r5}
 79c:	4770      	bx	lr
 79e:	bf00      	nop
 7a0:	e000e100 	.word	0xe000e100

000007a4 <hal_timer_chk_queue>:
 *
 * @param bsptimer
 */
static void
hal_timer_chk_queue(struct nrf52_hal_timer *bsptimer)
{
 7a4:	b570      	push	{r4, r5, r6, lr}
 7a6:	4605      	mov	r5, r0
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 7a8:	f3ef 8610 	mrs	r6, PRIMASK
  __ASM volatile ("cpsid i" : : : "memory");
 7ac:	b672      	cpsid	i
 7ae:	e013      	b.n	7d8 <hal_timer_chk_queue+0x34>
             * If we are within 3 ticks of RTC, we wont be able to set compare.
             * Thus, we have to service this timer early.
             */
            delta = -3;
        } else {
            tcntr = nrf_read_timer_cntr(bsptimer->tmr_reg);
 7b0:	6928      	ldr	r0, [r5, #16]
 7b2:	f7ff ff63 	bl	67c <nrf_read_timer_cntr>
            delta = 0;
 7b6:	2200      	movs	r2, #0
        }
        if ((int32_t)(tcntr - timer->expiry) >= delta) {
 7b8:	68e3      	ldr	r3, [r4, #12]
 7ba:	1ac0      	subs	r0, r0, r3
 7bc:	4290      	cmp	r0, r2
 7be:	db19      	blt.n	7f4 <hal_timer_chk_queue+0x50>
            TAILQ_REMOVE(&bsptimer->hal_timer_q, timer, link);
 7c0:	6923      	ldr	r3, [r4, #16]
 7c2:	b1a3      	cbz	r3, 7ee <hal_timer_chk_queue+0x4a>
 7c4:	6962      	ldr	r2, [r4, #20]
 7c6:	615a      	str	r2, [r3, #20]
 7c8:	6963      	ldr	r3, [r4, #20]
 7ca:	6922      	ldr	r2, [r4, #16]
 7cc:	601a      	str	r2, [r3, #0]
            timer->link.tqe_prev = NULL;
 7ce:	2300      	movs	r3, #0
 7d0:	6163      	str	r3, [r4, #20]
            timer->cb_func(timer->cb_arg);
 7d2:	6863      	ldr	r3, [r4, #4]
 7d4:	68a0      	ldr	r0, [r4, #8]
 7d6:	4798      	blx	r3
    while ((timer = TAILQ_FIRST(&bsptimer->hal_timer_q)) != NULL) {
 7d8:	696c      	ldr	r4, [r5, #20]
 7da:	b15c      	cbz	r4, 7f4 <hal_timer_chk_queue+0x50>
        if (bsptimer->tmr_rtc) {
 7dc:	78ab      	ldrb	r3, [r5, #2]
 7de:	2b00      	cmp	r3, #0
 7e0:	d0e6      	beq.n	7b0 <hal_timer_chk_queue+0xc>
            tcntr = hal_timer_read_bsptimer(bsptimer);
 7e2:	4628      	mov	r0, r5
 7e4:	f7ff ffb4 	bl	750 <hal_timer_read_bsptimer>
            delta = -3;
 7e8:	f06f 0202 	mvn.w	r2, #2
 7ec:	e7e4      	b.n	7b8 <hal_timer_chk_queue+0x14>
            TAILQ_REMOVE(&bsptimer->hal_timer_q, timer, link);
 7ee:	6963      	ldr	r3, [r4, #20]
 7f0:	61ab      	str	r3, [r5, #24]
 7f2:	e7e9      	b.n	7c8 <hal_timer_chk_queue+0x24>
            break;
        }
    }

    /* Any timers left on queue? If so, we need to set OCMP */
    timer = TAILQ_FIRST(&bsptimer->hal_timer_q);
 7f4:	696b      	ldr	r3, [r5, #20]
    if (timer) {
 7f6:	b133      	cbz	r3, 806 <hal_timer_chk_queue+0x62>
        nrf_timer_set_ocmp(bsptimer, timer->expiry);
 7f8:	68d9      	ldr	r1, [r3, #12]
 7fa:	4628      	mov	r0, r5
 7fc:	f7ff ff44 	bl	688 <nrf_timer_set_ocmp>
            nrf_rtc_disable_ocmp((NRF_RTC_Type *)bsptimer->tmr_reg);
        } else {
            nrf_timer_disable_ocmp(bsptimer->tmr_reg);
        }
    }
    __HAL_ENABLE_INTERRUPTS(ctx);
 800:	b906      	cbnz	r6, 804 <hal_timer_chk_queue+0x60>
  __ASM volatile ("cpsie i" : : : "memory");
 802:	b662      	cpsie	i
}
 804:	bd70      	pop	{r4, r5, r6, pc}
        if (bsptimer->tmr_rtc) {
 806:	78ab      	ldrb	r3, [r5, #2]
 808:	b11b      	cbz	r3, 812 <hal_timer_chk_queue+0x6e>
            nrf_rtc_disable_ocmp((NRF_RTC_Type *)bsptimer->tmr_reg);
 80a:	6928      	ldr	r0, [r5, #16]
 80c:	f7ff ff9b 	bl	746 <nrf_rtc_disable_ocmp>
 810:	e7f6      	b.n	800 <hal_timer_chk_queue+0x5c>
            nrf_timer_disable_ocmp(bsptimer->tmr_reg);
 812:	6928      	ldr	r0, [r5, #16]
 814:	f7ff ff92 	bl	73c <nrf_timer_disable_ocmp>
 818:	e7f2      	b.n	800 <hal_timer_chk_queue+0x5c>

0000081a <hal_timer_irq_handler>:
#if (MYNEWT_VAL(TIMER_0) || MYNEWT_VAL(TIMER_1) || MYNEWT_VAL(TIMER_2) || \
     MYNEWT_VAL(TIMER_3) || MYNEWT_VAL(TIMER_4))

static void
hal_timer_irq_handler(struct nrf52_hal_timer *bsptimer)
{
 81a:	b510      	push	{r4, lr}
    NRF_TIMER_Type *hwtimer;

    os_trace_isr_enter();

    /* Check interrupt source. If set, clear them */
    hwtimer = bsptimer->tmr_reg;
 81c:	6904      	ldr	r4, [r0, #16]
    compare = hwtimer->EVENTS_COMPARE[NRF_TIMER_CC_INT];
 81e:	f8d4 314c 	ldr.w	r3, [r4, #332]	; 0x14c
    if (compare) {
 822:	b113      	cbz	r3, 82a <hal_timer_irq_handler+0x10>
        hwtimer->EVENTS_COMPARE[NRF_TIMER_CC_INT] = 0;
 824:	2300      	movs	r3, #0
 826:	f8c4 314c 	str.w	r3, [r4, #332]	; 0x14c
    }

    /* XXX: make these stats? */
    /* Count # of timer isrs */
    ++bsptimer->timer_isrs;
 82a:	6883      	ldr	r3, [r0, #8]
 82c:	3301      	adds	r3, #1
 82e:	6083      	str	r3, [r0, #8]
     * counter is already passed the output compare value), we use the NVIC
     * to set a pending interrupt. This means that there will be no compare
     * flag set, so all we do is check to see if the compare interrupt is
     * enabled.
     */
    if (hwtimer->INTENCLR & NRF_TIMER_INT_MASK(NRF_TIMER_CC_INT)) {
 830:	f8d4 3308 	ldr.w	r3, [r4, #776]	; 0x308
 834:	f413 2f00 	tst.w	r3, #524288	; 0x80000
 838:	d100      	bne.n	83c <hal_timer_irq_handler+0x22>
        /* XXX: Recommended by nordic to make sure interrupts are cleared */
        compare = hwtimer->EVENTS_COMPARE[NRF_TIMER_CC_INT];
    }

    os_trace_isr_exit();
}
 83a:	bd10      	pop	{r4, pc}
        hal_timer_chk_queue(bsptimer);
 83c:	f7ff ffb2 	bl	7a4 <hal_timer_chk_queue>
        compare = hwtimer->EVENTS_COMPARE[NRF_TIMER_CC_INT];
 840:	f8d4 314c 	ldr.w	r3, [r4, #332]	; 0x14c
}
 844:	e7f9      	b.n	83a <hal_timer_irq_handler+0x20>
	...

00000848 <nrf52_timer0_irq_handler>:
#endif

#if MYNEWT_VAL(TIMER_0)
void
nrf52_timer0_irq_handler(void)
{
 848:	b508      	push	{r3, lr}
    hal_timer_irq_handler(&nrf52_hal_timer0);
 84a:	4802      	ldr	r0, [pc, #8]	; (854 <nrf52_timer0_irq_handler+0xc>)
 84c:	f7ff ffe5 	bl	81a <hal_timer_irq_handler>
}
 850:	bd08      	pop	{r3, pc}
 852:	bf00      	nop
 854:	200000f4 	.word	0x200000f4

00000858 <hal_timer_init>:
    uint8_t irq_num;
    struct nrf52_hal_timer *bsptimer;
    void *hwtimer;
    hal_timer_irq_handler_t irq_isr;

    NRF52_HAL_TIMER_RESOLVE(timer_num, bsptimer);
 858:	2805      	cmp	r0, #5
 85a:	dc1c      	bgt.n	896 <hal_timer_init+0x3e>
 85c:	4b12      	ldr	r3, [pc, #72]	; (8a8 <hal_timer_init+0x50>)
 85e:	f853 3020 	ldr.w	r3, [r3, r0, lsl #2]
 862:	b1d3      	cbz	r3, 89a <hal_timer_init+0x42>

    /* If timer is enabled do not allow init */
    if (bsptimer->tmr_enabled) {
 864:	781a      	ldrb	r2, [r3, #0]
 866:	b9d2      	cbnz	r2, 89e <hal_timer_init+0x46>
        rc = EINVAL;
        goto err;
    }

    switch (timer_num) {
 868:	b9d8      	cbnz	r0, 8a2 <hal_timer_init+0x4a>
    if (hwtimer == NULL) {
        rc = EINVAL;
        goto err;
    }

    bsptimer->tmr_reg = hwtimer;
 86a:	4a10      	ldr	r2, [pc, #64]	; (8ac <hal_timer_init+0x54>)
 86c:	611a      	str	r2, [r3, #16]
    bsptimer->tmr_irq_num = irq_num;
 86e:	2208      	movs	r2, #8
 870:	705a      	strb	r2, [r3, #1]
    NVIC->ICER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
 872:	4b0f      	ldr	r3, [pc, #60]	; (8b0 <hal_timer_init+0x58>)
 874:	f44f 7280 	mov.w	r2, #256	; 0x100
 878:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80
  __ASM volatile ("dsb 0xF":::"memory");
 87c:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
 880:	f3bf 8f6f 	isb	sy
    NVIC->IP[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 884:	22e0      	movs	r2, #224	; 0xe0
 886:	f883 2308 	strb.w	r2, [r3, #776]	; 0x308
  uint32_t vectors = (uint32_t )SCB->VTOR;
 88a:	f503 6340 	add.w	r3, r3, #3072	; 0xc00
 88e:	689b      	ldr	r3, [r3, #8]
  (* (int *) (vectors + ((int32_t)IRQn + NVIC_USER_IRQ_OFFSET) * 4)) = vector;
 890:	4a08      	ldr	r2, [pc, #32]	; (8b4 <hal_timer_init+0x5c>)
 892:	661a      	str	r2, [r3, #96]	; 0x60
    /* Disable IRQ, set priority and set vector in table */
    NVIC_DisableIRQ(irq_num);
    NVIC_SetPriority(irq_num, (1 << __NVIC_PRIO_BITS) - 1);
    NVIC_SetVector(irq_num, (uint32_t)irq_isr);

    return 0;
 894:	4770      	bx	lr

err:
    return rc;
 896:	2016      	movs	r0, #22
 898:	4770      	bx	lr
 89a:	2016      	movs	r0, #22
 89c:	4770      	bx	lr
 89e:	2016      	movs	r0, #22
 8a0:	4770      	bx	lr
 8a2:	2016      	movs	r0, #22
}
 8a4:	4770      	bx	lr
 8a6:	bf00      	nop
 8a8:	00000ae8 	.word	0x00000ae8
 8ac:	40008000 	.word	0x40008000
 8b0:	e000e100 	.word	0xe000e100
 8b4:	00000849 	.word	0x00000849

000008b8 <hal_timer_config>:
    NRF_TIMER_Type *hwtimer;
#if MYNEWT_VAL(TIMER_5)
    NRF_RTC_Type *rtctimer;
#endif

    NRF52_HAL_TIMER_RESOLVE(timer_num, bsptimer);
 8b8:	2805      	cmp	r0, #5
 8ba:	dc65      	bgt.n	988 <hal_timer_config+0xd0>
 8bc:	4b39      	ldr	r3, [pc, #228]	; (9a4 <hal_timer_config+0xec>)
 8be:	f853 0020 	ldr.w	r0, [r3, r0, lsl #2]
 8c2:	2800      	cmp	r0, #0
 8c4:	d062      	beq.n	98c <hal_timer_config+0xd4>
        return 0;
    }
#endif

    /* Set timer to desired frequency */
    div = NRF52_MAX_TIMER_FREQ / freq_hz;
 8c6:	4b38      	ldr	r3, [pc, #224]	; (9a8 <hal_timer_config+0xf0>)
 8c8:	fbb3 f1f1 	udiv	r1, r3, r1
    /*
     * Largest prescaler is 2^9 and must make sure frequency not too high.
     * If hwtimer is NULL it means that the timer was not initialized prior
     * to call.
     */
    if (bsptimer->tmr_enabled || (div == 0) || (div > 512) ||
 8cc:	7803      	ldrb	r3, [r0, #0]
 8ce:	2b00      	cmp	r3, #0
 8d0:	d15e      	bne.n	990 <hal_timer_config+0xd8>
 8d2:	2900      	cmp	r1, #0
 8d4:	d05e      	beq.n	994 <hal_timer_config+0xdc>
 8d6:	f5b1 7f00 	cmp.w	r1, #512	; 0x200
 8da:	d85d      	bhi.n	998 <hal_timer_config+0xe0>
        (bsptimer->tmr_reg == NULL)) {
 8dc:	6902      	ldr	r2, [r0, #16]
    if (bsptimer->tmr_enabled || (div == 0) || (div > 512) ||
 8de:	2a00      	cmp	r2, #0
 8e0:	d05c      	beq.n	99c <hal_timer_config+0xe4>
{
 8e2:	b430      	push	{r4, r5}
        rc = EINVAL;
        goto err;
    }

    if (div == 1) {
 8e4:	2901      	cmp	r1, #1
 8e6:	d013      	beq.n	910 <hal_timer_config+0x58>
        prescaler = 0;
    } else {
        /* Find closest prescaler */
        for (prescaler = 1; prescaler < 10; ++prescaler) {
 8e8:	2301      	movs	r3, #1
 8ea:	2b09      	cmp	r3, #9
 8ec:	d810      	bhi.n	910 <hal_timer_config+0x58>
            if (div <= (1 << prescaler)) {
 8ee:	2201      	movs	r2, #1
 8f0:	409a      	lsls	r2, r3
 8f2:	428a      	cmp	r2, r1
 8f4:	d202      	bcs.n	8fc <hal_timer_config+0x44>
        for (prescaler = 1; prescaler < 10; ++prescaler) {
 8f6:	3301      	adds	r3, #1
 8f8:	b2db      	uxtb	r3, r3
 8fa:	e7f6      	b.n	8ea <hal_timer_config+0x32>
                min_delta = div - (1 << (prescaler - 1));
 8fc:	1e5c      	subs	r4, r3, #1
 8fe:	2501      	movs	r5, #1
 900:	fa05 f404 	lsl.w	r4, r5, r4
 904:	1b0c      	subs	r4, r1, r4
                max_delta = (1 << prescaler) - div;
 906:	1a51      	subs	r1, r2, r1
                if (min_delta < max_delta) {
 908:	428c      	cmp	r4, r1
 90a:	d201      	bcs.n	910 <hal_timer_config+0x58>
                    prescaler -= 1;
 90c:	3b01      	subs	r3, #1
 90e:	b2db      	uxtb	r3, r3
            }
        }
    }

    /* Now set the actual frequency */
    bsptimer->tmr_freq = NRF52_MAX_TIMER_FREQ / (1 << prescaler);
 910:	4a25      	ldr	r2, [pc, #148]	; (9a8 <hal_timer_config+0xf0>)
 912:	411a      	asrs	r2, r3
 914:	60c2      	str	r2, [r0, #12]
    bsptimer->tmr_enabled = 1;
 916:	2201      	movs	r2, #1
 918:	7002      	strb	r2, [r0, #0]
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 91a:	f3ef 8410 	mrs	r4, PRIMASK
  __ASM volatile ("cpsid i" : : : "memory");
 91e:	b672      	cpsid	i

    /* disable interrupts */
    __HAL_DISABLE_INTERRUPTS(ctx);

    /* Make sure HFXO is started */
    if ((NRF_CLOCK->HFCLKSTAT &
 920:	f04f 4280 	mov.w	r2, #1073741824	; 0x40000000
 924:	f8d2 240c 	ldr.w	r2, [r2, #1036]	; 0x40c
 928:	f002 1201 	and.w	r2, r2, #65537	; 0x10001
 92c:	f1b2 1f01 	cmp.w	r2, #65537	; 0x10001
 930:	d00c      	beq.n	94c <hal_timer_config+0x94>
         (CLOCK_HFCLKSTAT_SRC_Msk | CLOCK_HFCLKSTAT_STATE_Msk)) !=
        (CLOCK_HFCLKSTAT_SRC_Msk | CLOCK_HFCLKSTAT_STATE_Msk)) {
        NRF_CLOCK->EVENTS_HFCLKSTARTED = 0;
 932:	f04f 4280 	mov.w	r2, #1073741824	; 0x40000000
 936:	2100      	movs	r1, #0
 938:	f8c2 1100 	str.w	r1, [r2, #256]	; 0x100
        NRF_CLOCK->TASKS_HFCLKSTART = 1;
 93c:	2101      	movs	r1, #1
 93e:	6011      	str	r1, [r2, #0]
        while (1) {
            if ((NRF_CLOCK->EVENTS_HFCLKSTARTED) != 0) {
 940:	f04f 4280 	mov.w	r2, #1073741824	; 0x40000000
 944:	f8d2 2100 	ldr.w	r2, [r2, #256]	; 0x100
 948:	2a00      	cmp	r2, #0
 94a:	d0f9      	beq.n	940 <hal_timer_config+0x88>
                break;
            }
        }
    }
    hwtimer = bsptimer->tmr_reg;
 94c:	6902      	ldr	r2, [r0, #16]

    /* Stop the timer first */
    hwtimer->TASKS_STOP = 1;
 94e:	2101      	movs	r1, #1
 950:	6051      	str	r1, [r2, #4]
    hwtimer->TASKS_CLEAR = 1;
 952:	60d1      	str	r1, [r2, #12]

    /* Put the timer in timer mode using 32 bits. */
    hwtimer->MODE = TIMER_MODE_MODE_Timer;
 954:	2500      	movs	r5, #0
 956:	f8c2 5504 	str.w	r5, [r2, #1284]	; 0x504
    hwtimer->BITMODE = TIMER_BITMODE_BITMODE_32Bit;
 95a:	2503      	movs	r5, #3
 95c:	f8c2 5508 	str.w	r5, [r2, #1288]	; 0x508

    /* Set the pre-scalar */
    hwtimer->PRESCALER = prescaler;
 960:	f8c2 3510 	str.w	r3, [r2, #1296]	; 0x510

    /* Start the timer */
    hwtimer->TASKS_START = 1;
 964:	6011      	str	r1, [r2, #0]

    NVIC_EnableIRQ(bsptimer->tmr_irq_num);
 966:	7842      	ldrb	r2, [r0, #1]
 968:	b253      	sxtb	r3, r2
  if ((int32_t)(IRQn) >= 0)
 96a:	2b00      	cmp	r3, #0
 96c:	db07      	blt.n	97e <hal_timer_config+0xc6>
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
 96e:	f002 021f 	and.w	r2, r2, #31
 972:	095b      	lsrs	r3, r3, #5
 974:	fa01 f202 	lsl.w	r2, r1, r2
 978:	490c      	ldr	r1, [pc, #48]	; (9ac <hal_timer_config+0xf4>)
 97a:	f841 2023 	str.w	r2, [r1, r3, lsl #2]

    __HAL_ENABLE_INTERRUPTS(ctx);
 97e:	b97c      	cbnz	r4, 9a0 <hal_timer_config+0xe8>
  __ASM volatile ("cpsie i" : : : "memory");
 980:	b662      	cpsie	i

    return 0;
 982:	2000      	movs	r0, #0

err:
    return rc;
}
 984:	bc30      	pop	{r4, r5}
 986:	4770      	bx	lr
    return rc;
 988:	2016      	movs	r0, #22
 98a:	4770      	bx	lr
 98c:	2016      	movs	r0, #22
 98e:	4770      	bx	lr
 990:	2016      	movs	r0, #22
 992:	4770      	bx	lr
 994:	2016      	movs	r0, #22
 996:	4770      	bx	lr
 998:	2016      	movs	r0, #22
 99a:	4770      	bx	lr
 99c:	2016      	movs	r0, #22
}
 99e:	4770      	bx	lr
    return 0;
 9a0:	2000      	movs	r0, #0
 9a2:	e7ef      	b.n	984 <hal_timer_config+0xcc>
 9a4:	00000ae8 	.word	0x00000ae8
 9a8:	00f42400 	.word	0x00f42400
 9ac:	e000e100 	.word	0xe000e100

000009b0 <__assert_func>:
}
#endif

void
__assert_func(const char *file, int line, const char *func, const char *e)
{
 9b0:	b508      	push	{r3, lr}
#if MYNEWT_VAL(OS_CRASH_LOG)
    struct log_reboot_info lri;
#endif
    int sr;

    OS_ENTER_CRITICAL(sr);
 9b2:	f000 f826 	bl	a02 <os_arch_save_sr>

#if MYNEWT_VAL(OS_ASSERT_CB)
    os_assert_cb();
#endif

    if (hal_debugger_connected()) {
 9b6:	f7ff fbd5 	bl	164 <hal_debugger_connected>
 9ba:	b100      	cbz	r0, 9be <__assert_func+0xe>
       /*
        * If debugger is attached, breakpoint before the trap.
        */
#if !MYNEWT_VAL(MCU_DEBUG_IGNORE_BKPT)
       asm("bkpt");
 9bc:	be00      	bkpt	0x0000
#endif
    }
    SCB->ICSR = SCB_ICSR_NMIPENDSET_Msk;
 9be:	4b04      	ldr	r3, [pc, #16]	; (9d0 <__assert_func+0x20>)
 9c0:	f04f 4200 	mov.w	r2, #2147483648	; 0x80000000
 9c4:	605a      	str	r2, [r3, #4]
    asm("isb");
 9c6:	f3bf 8f6f 	isb	sy
    hal_system_reset();
 9ca:	f7ff fbd3 	bl	174 <hal_system_reset>
 9ce:	bf00      	nop
 9d0:	e000ed00 	.word	0xe000ed00

000009d4 <os_default_irq>:
}

void
os_default_irq(struct trap_frame *tf)
{
 9d4:	b508      	push	{r3, lr}
    uint32_t orig_sp;
#endif

    console_blocking_mode();
    console_printf("Unhandled interrupt (%ld), exception sp 0x%08lx\n",
      SCB->ICSR & SCB_ICSR_VECTACTIVE_Msk, (uint32_t)tf->ef);
 9d6:	4b04      	ldr	r3, [pc, #16]	; (9e8 <os_default_irq+0x14>)
 9d8:	685a      	ldr	r2, [r3, #4]
      tf->r4, tf->r5, tf->r6, tf->r7);
    console_printf(" r8:0x%08lx  r9:0x%08lx r10:0x%08lx r11:0x%08lx\n",
      tf->r8, tf->r9, tf->r10, tf->r11);
    console_printf("r12:0x%08lx  lr:0x%08lx  pc:0x%08lx psr:0x%08lx\n",
      tf->ef->r12, tf->ef->lr, tf->ef->pc, tf->ef->psr);
    console_printf("ICSR:0x%08lx HFSR:0x%08lx CFSR:0x%08lx\n",
 9da:	685a      	ldr	r2, [r3, #4]
 9dc:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 9de:	6a9a      	ldr	r2, [r3, #40]	; 0x28
      SCB->ICSR, SCB->HFSR, SCB->CFSR);
    console_printf("BFAR:0x%08lx MMFAR:0x%08lx\n", SCB->BFAR, SCB->MMFAR);
 9e0:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 9e2:	6b5b      	ldr	r3, [r3, #52]	; 0x34
            : "r0"
        );
    }
#endif

    hal_system_reset();
 9e4:	f7ff fbc6 	bl	174 <hal_system_reset>
 9e8:	e000ed00 	.word	0xe000ed00

000009ec <os_cputime_init>:
struct os_cputime_data g_os_cputime;
#endif

int
os_cputime_init(uint32_t clock_freq)
{
 9ec:	b508      	push	{r3, lr}

    /* Set the ticks per microsecond. */
#if defined(OS_CPUTIME_FREQ_HIGH)
    g_os_cputime.ticks_per_usec = clock_freq / 1000000U;
#endif
    rc = hal_timer_config(MYNEWT_VAL(OS_CPUTIME_TIMER_NUM), clock_freq);
 9ee:	4601      	mov	r1, r0
 9f0:	2000      	movs	r0, #0
 9f2:	f7ff ff61 	bl	8b8 <hal_timer_config>
    return rc;
}
 9f6:	bd08      	pop	{r3, pc}

000009f8 <timer_handler>:
/* XXX: determine how we will deal with running un-privileged */
uint32_t os_flags = OS_RUN_PRIV;

void
timer_handler(void)
{
 9f8:	b508      	push	{r3, lr}
    os_time_advance(1);
 9fa:	2001      	movs	r0, #1
 9fc:	f000 f808 	bl	a10 <os_time_advance>
}
 a00:	bd08      	pop	{r3, pc}

00000a02 <os_arch_save_sr>:
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 a02:	f3ef 8010 	mrs	r0, PRIMASK
  __ASM volatile ("cpsid i" : : : "memory");
 a06:	b672      	cpsid	i
    uint32_t isr_ctx;

    isr_ctx = __get_PRIMASK();
    __disable_irq();
    return (isr_ctx & 1);
}
 a08:	f000 0001 	and.w	r0, r0, #1
 a0c:	4770      	bx	lr
	...

00000a10 <os_time_advance>:
#else

void
os_time_advance(int ticks)
{
    g_os_time += ticks;
 a10:	4a02      	ldr	r2, [pc, #8]	; (a1c <os_time_advance+0xc>)
 a12:	6813      	ldr	r3, [r2, #0]
 a14:	4418      	add	r0, r3
 a16:	6010      	str	r0, [r2, #0]
}
 a18:	4770      	bx	lr
 a1a:	bf00      	nop
 a1c:	20000118 	.word	0x20000118

00000a20 <os_set_env>:
        .global os_set_env
os_set_env:
        .fnstart
        .cantunwind

        MSR     PSP,R0
 a20:	f380 8809 	msr	PSP, r0
        LDR     R0,=os_flags
 a24:	482b      	ldr	r0, [pc, #172]	; (ad4 <os_default_irq_asm+0x1e>)
        LDRB    R0,[R0]
 a26:	7800      	ldrb	r0, [r0, #0]
        ADDS    R0, R0, #2
 a28:	3002      	adds	r0, #2
        MSR     CONTROL,R0
 a2a:	f380 8814 	msr	CONTROL, r0
        ISB
 a2e:	f3bf 8f6f 	isb	sy
        BX      LR
 a32:	4770      	bx	lr

00000a34 <os_arch_init_task_stack>:
        .type   os_arch_init_task_stack, %function
        .global os_arch_init_task_stack
os_arch_init_task_stack:
        .fnstart

        STMIA   R0,{R4-R11}
 a34:	e880 0ff0 	stmia.w	r0, {r4, r5, r6, r7, r8, r9, sl, fp}
        BX      LR
 a38:	4770      	bx	lr

00000a3a <SVC_Handler>:
        PUSH    {R4,LR}
        BL      os_trace_isr_enter
        POP     {R4,LR}
#endif

        MRS     R0,PSP                  /* Read PSP */
 a3a:	f3ef 8009 	mrs	r0, PSP
        LDR     R1,[R0,#24]             /* Read Saved PC from Stack */
 a3e:	6981      	ldr	r1, [r0, #24]
        LDRB    R1,[R1,#-2]             /* Load SVC Number */
 a40:	f811 1c02 	ldrb.w	r1, [r1, #-2]
        CBNZ    R1,SVC_User
 a44:	b951      	cbnz	r1, a5c <SVC_User>

        LDM     R0,{R0-R3,R12}          /* Read R0-R3,R12 from stack */
 a46:	e890 100f 	ldmia.w	r0, {r0, r1, r2, r3, ip}
        PUSH    {R4,LR}                 /* Save EXC_RETURN */
 a4a:	b510      	push	{r4, lr}
        BLX     R12                     /* Call SVC Function */
 a4c:	47e0      	blx	ip
        POP     {R4,LR}                 /* Restore EXC_RETURN */
 a4e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}

        MRS     R12,PSP                 /* Read PSP */
 a52:	f3ef 8c09 	mrs	ip, PSP
        STM     R12,{R0-R2}             /* Store return values */
 a56:	e88c 0007 	stmia.w	ip, {r0, r1, r2}
        PUSH    {R4,LR}
        BL      os_trace_isr_exit
        POP     {R4,LR}
#endif

        BX      LR                      /* Return from interrupt */
 a5a:	4770      	bx	lr

00000a5c <SVC_User>:

        /*------------------- User SVC ------------------------------*/
SVC_User:
        PUSH    {R4,LR}                 /* Save EXC_RETURN */
 a5c:	b510      	push	{r4, lr}
        LDR     R2,=SVC_Count
 a5e:	4a1e      	ldr	r2, [pc, #120]	; (ad8 <os_default_irq_asm+0x22>)
        LDR     R2,[R2]
 a60:	6812      	ldr	r2, [r2, #0]
        CMP     R1,R2
 a62:	4291      	cmp	r1, r2
        BHI     SVC_Done                /* Overflow */
 a64:	d809      	bhi.n	a7a <SVC_Done>

        LDR     R4,=SVC_Table-4
 a66:	4c1d      	ldr	r4, [pc, #116]	; (adc <os_default_irq_asm+0x26>)
        LDR     R4,[R4,R1,LSL #2]       /* Load SVC Function Address */
 a68:	f854 4021 	ldr.w	r4, [r4, r1, lsl #2]

        LDM     R0,{R0-R3,R12}          /* Read R0-R3,R12 from stack */
 a6c:	e890 100f 	ldmia.w	r0, {r0, r1, r2, r3, ip}
        BLX     R4                      /* Call SVC Function */
 a70:	47a0      	blx	r4

        MRS     R12,PSP
 a72:	f3ef 8c09 	mrs	ip, PSP
        STM     R12,{R0-R3}             /* Function return values */
 a76:	e88c 000f 	stmia.w	ip, {r0, r1, r2, r3}

00000a7a <SVC_Done>:
SVC_Done:
#if MYNEWT_VAL(OS_SYSVIEW)
        BL      os_trace_isr_exit
#endif
        POP     {R4,LR}                 /* Restore EXC_RETURN */
 a7a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
        BX      LR                      /* Return from interrupt */
 a7e:	4770      	bx	lr

00000a80 <PendSV_Handler>:
        .global PendSV_Handler
PendSV_Handler:
        .fnstart
        .cantunwind

        LDR     R3,=g_os_run_list       /* Get highest priority task ready to run */
 a80:	4b17      	ldr	r3, [pc, #92]	; (ae0 <os_default_irq_asm+0x2a>)
        LDR     R2,[R3]                 /* Store in R2 */
 a82:	681a      	ldr	r2, [r3, #0]
        LDR     R3,=g_current_task      /* Get current task */
 a84:	4b17      	ldr	r3, [pc, #92]	; (ae4 <os_default_irq_asm+0x2e>)
        LDR     R1,[R3]                 /* Current task in R1 */
 a86:	6819      	ldr	r1, [r3, #0]
        CMP     R1,R2
 a88:	4291      	cmp	r1, r2
        IT      EQ
 a8a:	bf08      	it	eq
        BXEQ    LR                      /* RETI, no task switch */
 a8c:	4770      	bxeq	lr

        MRS     R12,PSP                 /* Read PSP */
 a8e:	f3ef 8c09 	mrs	ip, PSP
        TST     LR,#0x10                /* is it extended frame? */
        IT      EQ
        VSTMDBEQ R12!,{S16-S31}         /* yes; push the regs */
        STMDB   R12!,{R4-R11,LR}        /* Save Old context */
#else
        STMDB   R12!,{R4-R11}           /* Save Old context */
 a92:	e92c 0ff0 	stmdb	ip!, {r4, r5, r6, r7, r8, r9, sl, fp}
#endif
        STR     R12,[R1,#0]             /* Update stack pointer in current task */
 a96:	f8c1 c000 	str.w	ip, [r1]
        STR     R2,[R3]                 /* g_current_task = highest ready */
 a9a:	601a      	str	r2, [r3, #0]

        LDR     R12,[R2,#0]             /* get stack pointer of task we will start */
 a9c:	f8d2 c000 	ldr.w	ip, [r2]
        ITTE    EQ
        VLDMIAEQ R12!,{S16-S31}         /* yes; pull the regs */
        MVNEQ   LR,#~0xFFFFFFED         /* BX treats it as extended */
        MVNNE   LR,#~0xFFFFFFFD         /* BX treats is as basic frame */
#else
        LDMIA   R12!,{R4-R11}           /* Restore New Context */
 aa0:	e8bc 0ff0 	ldmia.w	ip!, {r4, r5, r6, r7, r8, r9, sl, fp}
#endif
        MSR     PSP,R12                 /* Write PSP */
 aa4:	f38c 8809 	msr	PSP, ip
        MOV     R0, R2
        BL      os_trace_task_start_exec
        POP     {R4,LR}
#endif

        BX      LR                      /* Return to Thread Mode */
 aa8:	4770      	bx	lr

00000aaa <SysTick_Handler>:
        .global SysTick_Handler
SysTick_Handler:
        .fnstart
        .cantunwind

        PUSH    {R4,LR}                 /* Save EXC_RETURN */
 aaa:	b510      	push	{r4, lr}
#if MYNEWT_VAL(OS_SYSVIEW)
        BL      os_trace_isr_enter
#endif
        BL      timer_handler
 aac:	f7ff ffa4 	bl	9f8 <timer_handler>
#if MYNEWT_VAL(OS_SYSVIEW)
        BL      os_trace_isr_exit
#endif
        POP     {R4,LR}                 /* Restore EXC_RETURN */
 ab0:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
        BX      LR
 ab4:	4770      	bx	lr

00000ab6 <os_default_irq_asm>:

        /*
         * LR = 0xfffffff9 if we were using MSP as SP
         * LR = 0xfffffffd if we were using PSP as SP
         */
        TST     LR,#4
 ab6:	f01e 0f04 	tst.w	lr, #4
        ITE     EQ
 aba:	bf0c      	ite	eq
        MRSEQ   R3,MSP
 abc:	f3ef 8308 	mrseq	r3, MSP
        MRSNE   R3,PSP
 ac0:	f3ef 8309 	mrsne	r3, PSP
        PUSH    {R3-R11,LR}
 ac4:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
        MOV     R0, SP
 ac8:	4668      	mov	r0, sp
        BL      os_default_irq
 aca:	f7ff ff83 	bl	9d4 <os_default_irq>
        POP     {R3-R11,LR}                 /* Restore EXC_RETURN */
 ace:	e8bd 4ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
        PUSH    {R4,LR}
        BL      os_trace_isr_exit
        POP     {R4,LR}
#endif

        BX      LR
 ad2:	4770      	bx	lr
        LDR     R0,=os_flags
 ad4:	200000f0 	.word	0x200000f0
        LDR     R2,=SVC_Count
 ad8:	00000000 	.word	0x00000000
        LDR     R4,=SVC_Table-4
 adc:	fffffffc 	.word	0xfffffffc
        LDR     R3,=g_os_run_list       /* Get highest priority task ready to run */
 ae0:	200000e8 	.word	0x200000e8
        LDR     R3,=g_current_task      /* Get current task */
 ae4:	20000110 	.word	0x20000110

00000ae8 <nrf52_hal_timers>:
 ae8:	200000f4 00000000 00000000 00000000     ... ............
	...

00000b00 <sysflash_map_dflt>:
	...
 b08:	00004000 00000001 00008000 00073c00     .@...........<..
 b18:	00000002 0007bc00 00000400 00000003     ................
 b28:	0007c000 00001000 00000010 00004000     .............@..
 b38:	00004000 00000011 0007d000 00003000     .@...........0..

/home/pi/pinetime-rust-mynewt/bin/targets/nrf52_boot/app/apps/boot_stub/boot_stub.elf:     file format elf32-littlearm

arm-none-eabi-objdump: section '.rodata' mentioned in a -j option, but not found in any input file
   text	   data	    bss	    dec	    hex	filename
   2912	     24	    260	   3196	    c7c	/home/pi/pinetime-rust-mynewt/bin/targets/nrf52_boot/app/apps/boot_stub/boot_stub.elf
